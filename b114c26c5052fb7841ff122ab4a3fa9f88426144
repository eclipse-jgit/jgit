{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "202e7b1c_16c726c1",
        "filename": "org.eclipse.jgit.test/tst/org/eclipse/jgit/internal/storage/file/GcKeepFilesTest.java",
        "patchSetId": 6
      },
      "lineNbr": 94,
      "author": {
        "id": 49
      },
      "writtenOn": "2023-09-21T11:28:39Z",
      "side": 1,
      "message": "This test case replicates a scenario that will never happen in real life.\n\nWhat we do here, is that we create two commits, run GC twice and then say: \"hey git, you know what, you haven\u0027t seen the second PACK file as it is not complete, right?\". We also use the same `Repository` instance, meaning it has the internal state that we try to influence with the `.keep` file.\n\nAlso if we push the same PACK file to git, it should ignore it, as the PACK sha1 will be the same (similarly for the objects).\n\nTo replicate what\u0027s going on, we should have two separate git repositories, crate commit in the first one copy/clone it. Amend that commit, then push (or copy PACK files), create a `.keep` file and finally run the GC.\n\nWith amending, we\u0027ll convince Git to create a new PACK file that would have a new commit object and reuse tree and blob objects.\n\nThis should truly simulate a situation when there\u0027s an outgoing push with PACK files that have new and old objects while the GC is running.",
      "range": {
        "startLine": 88,
        "startChar": 0,
        "endLine": 94,
        "endChar": 39
      },
      "revId": "b114c26c5052fb7841ff122ab4a3fa9f88426144",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "97caf77b_184925bc",
        "filename": "org.eclipse.jgit.test/tst/org/eclipse/jgit/internal/storage/file/GcKeepFilesTest.java",
        "patchSetId": 6
      },
      "lineNbr": 94,
      "author": {
        "id": 97483
      },
      "writtenOn": "2023-09-21T20:21:16Z",
      "side": 1,
      "message": "\u003e This test case replicates a scenario that will never happen in real life.\n\nIt is a simulated scenario, yes. However, it tries to _mimic_ the case where a packfile (locked with the .keep) contains objects also contained in other packfiles, which is a scenario that _may_ happen in real life.\n\n\u003e What we do here, is that we create two commits, run GC twice and then say: \"hey git, you know what, you haven\u0027t seen the second PACK file as it is not complete, right?\". We also use the same `Repository` instance, meaning it has the internal state that we try to influence with the `.keep` file.\n\nTrue.\n\n\u003e Also if we push the same PACK file to git, it should ignore it, as the PACK sha1 will be the same (similarly for the objects).\n\nThat\u0027s not true: packfiles are always discovered and kept in the pack list in memory. Also, two packfiles cannot have the same SHA1s because the name is obtained with a combined SHA1 of all its sorted content: if you have two packfiles with the same content, they are the same file with the same name.\n\nIf the second packfile (with a .keep associated) has extra SHA1s, then it never ignored, even if it has a .keep associated. The keep file is just used for checking if the file should be kept during the prune phase of a repack.\n\n\u003e To replicate what\u0027s going on, we should have two separate git repositories, crate commit in the first one copy/clone it. Amend that commit, then push (or copy PACK files), create a `.keep` file and finally run the GC.\n\nYou could also replicate with two repositories an a push, however, you would have to create the `.keep` file artificially, so it would still be a simulated scenario.\n\n\u003e With amending, we\u0027ll convince Git to create a new PACK file that would have a new commit object and reuse tree and blob objects.\n\u003e This should truly simulate a situation when there\u0027s an outgoing push with PACK files that have new and old objects while the GC is running.\n\nHave you tried yourself? Would that generate a packfile with duplicates objects on the server side of the push?",
      "parentUuid": "202e7b1c_16c726c1",
      "range": {
        "startLine": 88,
        "startChar": 0,
        "endLine": 94,
        "endChar": 39
      },
      "revId": "b114c26c5052fb7841ff122ab4a3fa9f88426144",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "abb28f8a_06c15755",
        "filename": "org.eclipse.jgit.test/tst/org/eclipse/jgit/internal/storage/file/GcKeepFilesTest.java",
        "patchSetId": 6
      },
      "lineNbr": 94,
      "author": {
        "id": 49
      },
      "writtenOn": "2023-09-21T23:26:30Z",
      "side": 1,
      "message": "Let\u0027s walk through this test case and examine the `.git` content.\n\nOn the first GC, line 82, we got:\n```\n├── objects\n│   ├── info\n│   │   └── packs\n│   └── pack\n│       ├── pack-ba4ae147a00c93991e42fc810fa1004f7d4ee5a8.bitmap\n│       ├── pack-ba4ae147a00c93991e42fc810fa1004f7d4ee5a8.idx\n│       └── pack-ba4ae147a00c93991e42fc810fa1004f7d4ee5a8.pack\n```\n\nNote that we already have a BITMAP file. Then on the second GC, line 85, we have:\n```\n├── objects\n│   ├── info\n│   │   └── packs\n│   └── pack\n│       ├── pack-786b884c05e1d772adfb1a088b669cb0dde9621f.bitmap\n│       ├── pack-786b884c05e1d772adfb1a088b669cb0dde9621f.idx\n│       ├── pack-786b884c05e1d772adfb1a088b669cb0dde9621f.pack\n│       ├── pack-ba4ae147a00c93991e42fc810fa1004f7d4ee5a8.bitmap\n│       ├── pack-ba4ae147a00c93991e42fc810fa1004f7d4ee5a8.idx\n│       └── pack-ba4ae147a00c93991e42fc810fa1004f7d4ee5a8.pack\n```\n\nNote that we have BITMAP files for both PACKs. Now let\u0027s see what\u0027s the content of the pack files:\n```\n$ git verify-pack -v objects/pack/pack-ba4ae147a00c93991e42fc810fa1004f7d4ee5a8.pack                                                                                                                                                      \n\nAlias tip: g verify-pack -v objects/pack/pack-ba4ae147a00c93991e42fc810fa1004f7d4ee5a8.pack\n99a044cfdb1757ee915ae9fbd5d869ee3bc138f5 commit 168 121 12\n617601c79811cbbae338512798318b4e5b70c9ac tree   29 39 133\n8c7e5a667f1b771847fe88c01c3de34413a1b220 blob   1 10 172\nnon delta: 3 objects\nobjects/pack/pack-ba4ae147a00c93991e42fc810fa1004f7d4ee5a8.pack: ok\n```\n\n\nand for the PACK file created by the second GC, we get:\n```\n$ git verify-pack -v objects/pack/pack-786b884c05e1d772adfb1a088b669cb0dde9621f.pack                                                                                                                                                     \n\nAlias tip: g verify-pack -v objects/pack/pack-786b884c05e1d772adfb1a088b669cb0dde9621f.pack\n69896df2d557bf7e0d7a3ca5af682ad361739819 commit 216 152 12\n99a044cfdb1757ee915ae9fbd5d869ee3bc138f5 commit 168 121 164\nf6dc85adf6f1fa7fafdd9d57cf66bf6926145bb3 tree   58 65 285\n617601c79811cbbae338512798318b4e5b70c9ac tree   29 39 350\n8c7e5a667f1b771847fe88c01c3de34413a1b220 blob   1 10 389\n7371f47a6f8bd23a8fa1a8b2a9479cdd76380e54 blob   1 10 399\nnon delta: 6 objects\nobjects/pack/pack-786b884c05e1d772adfb1a088b669cb0dde9621f.pack: ok\n```\n\nTo recap, we ran GC twice and got two triplets, an IDX, PACK and BITMAP file. The first one contains objects for the first commit. The second one has objects for both commits.\n\nLet\u0027s move to the code that creates the .keep file:\n```\n├── objects\n│   ├── info\n│   │   └── packs\n│   └── pack\n│       ├── pack-786b884c05e1d772adfb1a088b669cb0dde9621f.bitmap\n│       ├── pack-786b884c05e1d772adfb1a088b669cb0dde9621f.idx\n│       ├── pack-786b884c05e1d772adfb1a088b669cb0dde9621f.pack\n│       ├── pack-ba4ae147a00c93991e42fc810fa1004f7d4ee5a8.bitmap\n│       ├── pack-ba4ae147a00c93991e42fc810fa1004f7d4ee5a8.idx\n│       ├── pack-ba4ae147a00c93991e42fc810fa1004f7d4ee5a8.keep\n│       └── pack-ba4ae147a00c93991e42fc810fa1004f7d4ee5a8.pack\n```\n\nAs you can see, the .keep file is created for the **first** PACK file triplet. That triplet contains objects only for the first commit. **That\u0027s the first discrepancy**.\n\nSecondly, during the push operation, BITMAP files are **not** created. But this test case creates them for both PACK files.\n\nAdditionally, that test case reuses the same repository instance, which means that it relies on its internal state, which may not be true for the Gerrit server.\n\n\u003e That\u0027s not true: packfiles are always discovered and kept in the pack list in memory. Also, two packfiles cannot have the same SHA1s because the name is obtained with a combined SHA1 of all its sorted content: if you have two packfiles with the same content, they are the same file with the same name.\n\nWell, this test case assumes that a PACK file was created that was already seen by the \"server\". This means that the PACK file had the same SHA-1. Also, that\u0027s my point, if you push a PACK file that has the same content as one in the repository it should be ignored (as both have the same SHA-1).\n\n\u003e You could also replicate with two repositories an a push, however, you would have to create the `.keep` file artificially, so it would still be a simulated scenario.\n\nYes, you still need to create a .keep file artificially, but at least in the case of my test case it also requires a new `FileRepository` instance as the test instance (the `tr` protected member) did not \"see\" the pushed PACK file.\n\n\u003e Have you tried yourself? Would that generate a packfile with duplicates objects on the server side of the push?\n\nYes, I did. In my test case, I ended up with two PACK files (only one had BITMAP) and both had the same TREE and BLOB objects. **But** it resulted in a different excepton:\n\n```\njava.lang.IllegalStateException\n\tat org.eclipse.jgit.internal.storage.file.PackBitmapIndexBuilder.generateStoredEntry(PackBitmapIndexBuilder.java:191)\n\tat org.eclipse.jgit.internal.storage.file.PackBitmapIndexBuilder.getCompressedBitmaps(PackBitmapIndexBuilder.java:328)\n\tat org.eclipse.jgit.internal.storage.file.PackBitmapIndexWriterV1.writeBitmaps(PackBitmapIndexWriterV1.java:101)\n\tat org.eclipse.jgit.internal.storage.file.PackBitmapIndexWriterV1.writeBody(PackBitmapIndexWriterV1.java:91)\n\tat org.eclipse.jgit.internal.storage.file.PackBitmapIndexWriterV1.write(PackBitmapIndexWriterV1.java:70)\n\tat org.eclipse.jgit.internal.storage.pack.PackWriter.writeBitmapIndex(PackWriter.java:1134)\n\tat org.eclipse.jgit.internal.storage.file.GC.writePack(GC.java:1232)\n\tat org.eclipse.jgit.internal.storage.file.GC.repack(GC.java:864)\n\tat org.eclipse.jgit.internal.storage.file.GC.doGc(GC.java:285)\n\tat org.eclipse.jgit.internal.storage.file.GC.gc(GC.java:232)\n\tat org.eclipse.jgit.internal.storage.file.GcKeepFilesTest.testKeepFileAllowsBitmapRemapping2(GcKeepFilesTest.java:136)\n```",
      "parentUuid": "97caf77b_184925bc",
      "range": {
        "startLine": 88,
        "startChar": 0,
        "endLine": 94,
        "endChar": 39
      },
      "revId": "b114c26c5052fb7841ff122ab4a3fa9f88426144",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31"
    }
  ]
}