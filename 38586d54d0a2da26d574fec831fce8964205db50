{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "cce9b4c1_6beaa35a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 92
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-01-24T13:57:57Z",
      "side": 1,
      "message": "Post-merge -1: I don\u0027t understand the testRacyReload()",
      "revId": "38586d54d0a2da26d574fec831fce8964205db50",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3a1745a0_510555e7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 92
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-01-25T19:20:14Z",
      "side": 1,
      "message": "Thanks again @hanwenn@gmail.com for taking the time to follow this up, it is much clearer to me now.",
      "revId": "38586d54d0a2da26d574fec831fce8964205db50",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f928708b_14ac9263",
        "filename": "org.eclipse.jgit.test/tst/org/eclipse/jgit/internal/storage/file/FileReftableTest.java",
        "patchSetId": 92
      },
      "lineNbr": 94,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-01-24T13:57:57Z",
      "side": 1,
      "message": "The name of the test should tell what the test is expecting to achieve; example _\"tesRacyReloadShouldSucceedOnlyOnce\"_.\n\nWhat was the overall object of this test?\n\nTests are the only piece of code that aren\u0027t tested (unless you write the test of a test) and the code here below doesn\u0027t really express what is the overall expectation of the end-to-end functionality.",
      "range": {
        "startLine": 94,
        "startChar": 13,
        "endLine": 94,
        "endChar": 27
      },
      "revId": "38586d54d0a2da26d574fec831fce8964205db50",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "683921e2_a061295c",
        "filename": "org.eclipse.jgit.test/tst/org/eclipse/jgit/internal/storage/file/FileReftableTest.java",
        "patchSetId": 92
      },
      "lineNbr": 94,
      "author": {
        "id": 1007980
      },
      "writtenOn": "2025-01-24T14:49:16Z",
      "side": 1,
      "message": "sure. Your code review comment is a bit late, though.",
      "parentUuid": "f928708b_14ac9263",
      "range": {
        "startLine": 94,
        "startChar": 13,
        "endLine": 94,
        "endChar": 27
      },
      "revId": "38586d54d0a2da26d574fec831fce8964205db50",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bf6a69b8_d2225318",
        "filename": "org.eclipse.jgit.test/tst/org/eclipse/jgit/internal/storage/file/FileReftableTest.java",
        "patchSetId": 92
      },
      "lineNbr": 94,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-01-24T18:10:58Z",
      "side": 1,
      "message": "\u003e sure. Your code review comment is a bit late, though.\n\nI know ðŸ˜Š ... better later than never!",
      "parentUuid": "683921e2_a061295c",
      "range": {
        "startLine": 94,
        "startChar": 13,
        "endLine": 94,
        "endChar": 27
      },
      "revId": "38586d54d0a2da26d574fec831fce8964205db50",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0679ea8a_ed211662",
        "filename": "org.eclipse.jgit.test/tst/org/eclipse/jgit/internal/storage/file/FileReftableTest.java",
        "patchSetId": 92
      },
      "lineNbr": 115,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-01-24T13:57:57Z",
      "side": 1,
      "message": "I see that all iterations of this loop use a different branch name:\n- j\u003d0; i\u003d0 \u003d\u003e branch0\n- j\u003d1; i\u003d0 \u003d\u003e branch1\n- j\u003d0; i\u003d1 \u003d\u003e branch10\n- j\u003d1; i\u003d0 \u003d\u003e branch11\n...\n\nWhy are we expecting the update to fail? If the update fails, why are we retrying unconditionally? (we should check for lock failures instead?) Why are we retrying only once?",
      "range": {
        "startLine": 108,
        "startChar": 0,
        "endLine": 115,
        "endChar": 34
      },
      "revId": "38586d54d0a2da26d574fec831fce8964205db50",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b1e970b4_40099651",
        "filename": "org.eclipse.jgit.test/tst/org/eclipse/jgit/internal/storage/file/FileReftableTest.java",
        "patchSetId": 92
      },
      "lineNbr": 115,
      "author": {
        "id": 1007980
      },
      "writtenOn": "2025-01-24T14:49:16Z",
      "side": 1,
      "message": "have a look at FileReftableDatabase::addReftable\n\nA ref update in repo1 causes the tables.list to updated, so repo2 has an outdated view and will fail any write that is applied. If this happens, the update fails, but tables.list is reloaded. So the 2nd try goes through.\n\nin the loose files storage, such changes can run concurrently.\n\nif you were writing the same branch, you would always have a failure, regardless of backend.",
      "parentUuid": "0679ea8a_ed211662",
      "range": {
        "startLine": 108,
        "startChar": 0,
        "endLine": 115,
        "endChar": 34
      },
      "revId": "38586d54d0a2da26d574fec831fce8964205db50",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8571ebc2_bcaf8553",
        "filename": "org.eclipse.jgit.test/tst/org/eclipse/jgit/internal/storage/file/FileReftableTest.java",
        "patchSetId": 92
      },
      "lineNbr": 115,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-01-24T18:10:58Z",
      "side": 1,
      "message": "\u003e have a look at FileReftableDatabase::addReftable\n\u003e \n\u003e A ref update in repo1 causes the tables.list to updated, so repo2 has an outdated view and will fail any write that is applied.\n\nI understand it better now, thanks. Do you believe that the retry should be implicit in the update() though?\nAlso, what if you did not perform an update() but simply a read of an outdated ref, then it would not fail and the data returned would be stale.\n\n\u003e If this happens, the update fails, but tables.list is reloaded. So the 2nd try goes through.\n\u003e \n\u003e in the loose files storage, such changes can run concurrently.\n\nI see, but it seems that you are testing the internal implementation details of what the current implementation of ref-table does, rather than testing what an external user should see from a ref-database.\n\n\u003e if you were writing the same branch, you would always have a failure, regardless of backend.\n\nMakes sense. Thanks for clarifying it.",
      "parentUuid": "b1e970b4_40099651",
      "range": {
        "startLine": 108,
        "startChar": 0,
        "endLine": 115,
        "endChar": 34
      },
      "revId": "38586d54d0a2da26d574fec831fce8964205db50",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "922602ad_0be200f1",
        "filename": "org.eclipse.jgit.test/tst/org/eclipse/jgit/internal/storage/file/FileReftableTest.java",
        "patchSetId": 92
      },
      "lineNbr": 115,
      "author": {
        "id": 1007980
      },
      "writtenOn": "2025-01-25T15:55:23Z",
      "side": 1,
      "message": "\u003eAlso, what if you did not perform an update() but simply a read of an outdated ref, then it would not fail and the data \u003ereturned would be stale.\n\nref updates are usually part of a transaction, where  you read the database at a fixed timestamp, create an update based on what you read, and then try to commit it. If the intervening update changed what you read, the transaction would no longer be valid and should be redone as a whole.\n\nReading stale data is a fact of life in any system that allows concurrent access.\n\n\u003eI see, but it seems that you are testing the internal implementation details of what the current implementation of ref-table does, rather than testing what an external user should see from a ref-database.\n\nIt is testing code that was written. \n\nInstead of complaining, why don\u0027t you say what your real problem is?\n\nNote that the CGit reftable code was originally inspired by this code. There have been several performance fixes to it since it was committed into CGit.",
      "parentUuid": "8571ebc2_bcaf8553",
      "range": {
        "startLine": 108,
        "startChar": 0,
        "endLine": 115,
        "endChar": 34
      },
      "revId": "38586d54d0a2da26d574fec831fce8964205db50",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7aebfd1d_48b627ba",
        "filename": "org.eclipse.jgit.test/tst/org/eclipse/jgit/internal/storage/file/FileReftableTest.java",
        "patchSetId": 92
      },
      "lineNbr": 115,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-01-25T19:20:14Z",
      "side": 1,
      "message": "\u003e \u003eAlso, what if you did not perform an update() but simply a read of an outdated ref, then it would not fail and the data \u003ereturned would be stale.\n\u003e \n\u003e ref updates are usually part of a transaction, where  you read the database at a fixed timestamp, create an update based on what you read, and then try to commit it. If the intervening update changed what you read, the transaction would no longer be valid and should be redone as a whole.\n\nMakes sense, when there is a ref-update involved.\n\n\u003e Reading stale data is a fact of life in any system that allows concurrent access.\n\nSure, every variable read is stale by definition after the read operation.\n\n\u003e \u003eI see, but it seems that you are testing the internal implementation details of what the current implementation of ref-table does, rather than testing what an external user should see from a ref-database.\n\u003e \n\u003e It is testing code that was written. \n\nYep, that\u0027s what I thought: it\u0027s a white-box testing.\n\n\u003e Instead of complaining, why don\u0027t you say what your real problem is?\n\nApologies if my tone was perceived as a complaint: the intent of the test was not clear to me and that\u0027s why I commented on the change. It isn\u0027t a complaint.\n\nThe Issue jgit-102 was raised (https://github.com/eclipse-jgit/jgit/issues/102) on ref-table not being able to detect changes on the underlying filesystem, which I believe it is expected as the refresh is done upon updates. If the update happened outside of the ref-table code, then it won\u0027t be seen.\n\nMatthias has drafted a fix with Change 1206683 (https://eclipse.gerrithub.io/c/eclipse-jgit/jgit/+/1206683) which breaks this test and I was trying to understand if that was because an external expected functionality would break or if this was just a white-box testing which is expected to break once the implementation changes.\n\n\u003e Note that the CGit reftable code was originally inspired by this code. There have been several performance fixes to it since it was committed into CGit.\n\nI have noticed a lot of different behaviour between CGit reftable and JGit, as it is largely expected as the CGit one is relatively new. I tried to run a simple test using both together and ended up with a corrupted repository very quickly :-(",
      "parentUuid": "922602ad_0be200f1",
      "range": {
        "startLine": 108,
        "startChar": 0,
        "endLine": 115,
        "endChar": 34
      },
      "revId": "38586d54d0a2da26d574fec831fce8964205db50",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bfe21477_9d89705d",
        "filename": "org.eclipse.jgit.test/tst/org/eclipse/jgit/internal/storage/file/FileReftableTest.java",
        "patchSetId": 92
      },
      "lineNbr": 115,
      "author": {
        "id": 1007980
      },
      "writtenOn": "2025-01-26T10:47:45Z",
      "side": 1,
      "message": "\u003e Matthias has drafted a fix with Change 1206683 (https://eclipse.gerrithub.io/c/eclipse-jgit/jgit/+/1206683) which breaks this test and I was trying to understand if that was because an external expected functionality would break or if this was just a white-box testing which is expected to break once the implementation changes.\n\nI don\u0027t think the bugreport is a bug per se. The 2nd read is delivering the value it read when it took the snapshot. What does JGit promise about how things are supposed to work? As discussed, exactRef can always return a stale data. If the reporter has expectations about ordering, they should use synchronization mechanism to disambiguate how stale they allow their data to be.\n\nBy rereading the DB at random in a exactRef() and friends, you make it impossible for anyone to build a system that creates consistent transactions (reader runs the risk of seeing a frankenstein of snapshot versions when doing the reads.) \n\nIn general, that may not be a big deal, but since you are in the business of building databases on top of git (NoteDB), that sounds like a risky tradeoff to make. (Also it inserts a disk read in a potentially hot code path; not great for performance)\n\n\u003e I tried to run a simple test using both together and ended up with a corrupted repository very quickly :-(\n\nI\u0027m sorry to hear that. AFAIK, there was no incompatiblity in storage format, so that should not happen. Do you have a reproducible scenario?",
      "parentUuid": "7aebfd1d_48b627ba",
      "range": {
        "startLine": 108,
        "startChar": 0,
        "endLine": 115,
        "endChar": 34
      },
      "revId": "38586d54d0a2da26d574fec831fce8964205db50",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    }
  ]
}