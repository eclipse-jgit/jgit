{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "cce9b4c1_6beaa35a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 92
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-01-24T13:57:57Z",
      "side": 1,
      "message": "Post-merge -1: I don\u0027t understand the testRacyReload()",
      "revId": "38586d54d0a2da26d574fec831fce8964205db50",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3a1745a0_510555e7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 92
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-01-25T19:20:14Z",
      "side": 1,
      "message": "Thanks again @hanwenn@gmail.com for taking the time to follow this up, it is much clearer to me now.",
      "revId": "38586d54d0a2da26d574fec831fce8964205db50",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f928708b_14ac9263",
        "filename": "org.eclipse.jgit.test/tst/org/eclipse/jgit/internal/storage/file/FileReftableTest.java",
        "patchSetId": 92
      },
      "lineNbr": 94,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-01-24T13:57:57Z",
      "side": 1,
      "message": "The name of the test should tell what the test is expecting to achieve; example _\"tesRacyReloadShouldSucceedOnlyOnce\"_.\n\nWhat was the overall object of this test?\n\nTests are the only piece of code that aren\u0027t tested (unless you write the test of a test) and the code here below doesn\u0027t really express what is the overall expectation of the end-to-end functionality.",
      "range": {
        "startLine": 94,
        "startChar": 13,
        "endLine": 94,
        "endChar": 27
      },
      "revId": "38586d54d0a2da26d574fec831fce8964205db50",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "683921e2_a061295c",
        "filename": "org.eclipse.jgit.test/tst/org/eclipse/jgit/internal/storage/file/FileReftableTest.java",
        "patchSetId": 92
      },
      "lineNbr": 94,
      "author": {
        "id": 1007980
      },
      "writtenOn": "2025-01-24T14:49:16Z",
      "side": 1,
      "message": "sure. Your code review comment is a bit late, though.",
      "parentUuid": "f928708b_14ac9263",
      "range": {
        "startLine": 94,
        "startChar": 13,
        "endLine": 94,
        "endChar": 27
      },
      "revId": "38586d54d0a2da26d574fec831fce8964205db50",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bf6a69b8_d2225318",
        "filename": "org.eclipse.jgit.test/tst/org/eclipse/jgit/internal/storage/file/FileReftableTest.java",
        "patchSetId": 92
      },
      "lineNbr": 94,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-01-24T18:10:58Z",
      "side": 1,
      "message": "\u003e sure. Your code review comment is a bit late, though.\n\nI know ðŸ˜Š ... better later than never!",
      "parentUuid": "683921e2_a061295c",
      "range": {
        "startLine": 94,
        "startChar": 13,
        "endLine": 94,
        "endChar": 27
      },
      "revId": "38586d54d0a2da26d574fec831fce8964205db50",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3d97781b_8b5da6e6",
        "filename": "org.eclipse.jgit.test/tst/org/eclipse/jgit/internal/storage/file/FileReftableTest.java",
        "patchSetId": 92
      },
      "lineNbr": 94,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-01-27T16:46:40Z",
      "side": 1,
      "message": "All clarified now, thanks @hanwenn@gmail.com ! I\u0027ll upload a new change with more descriptive names and info to the test.",
      "parentUuid": "bf6a69b8_d2225318",
      "range": {
        "startLine": 94,
        "startChar": 13,
        "endLine": 94,
        "endChar": 27
      },
      "revId": "38586d54d0a2da26d574fec831fce8964205db50",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0679ea8a_ed211662",
        "filename": "org.eclipse.jgit.test/tst/org/eclipse/jgit/internal/storage/file/FileReftableTest.java",
        "patchSetId": 92
      },
      "lineNbr": 115,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-01-24T13:57:57Z",
      "side": 1,
      "message": "I see that all iterations of this loop use a different branch name:\n- j\u003d0; i\u003d0 \u003d\u003e branch0\n- j\u003d1; i\u003d0 \u003d\u003e branch1\n- j\u003d0; i\u003d1 \u003d\u003e branch10\n- j\u003d1; i\u003d0 \u003d\u003e branch11\n...\n\nWhy are we expecting the update to fail? If the update fails, why are we retrying unconditionally? (we should check for lock failures instead?) Why are we retrying only once?",
      "range": {
        "startLine": 108,
        "startChar": 0,
        "endLine": 115,
        "endChar": 34
      },
      "revId": "38586d54d0a2da26d574fec831fce8964205db50",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b1e970b4_40099651",
        "filename": "org.eclipse.jgit.test/tst/org/eclipse/jgit/internal/storage/file/FileReftableTest.java",
        "patchSetId": 92
      },
      "lineNbr": 115,
      "author": {
        "id": 1007980
      },
      "writtenOn": "2025-01-24T14:49:16Z",
      "side": 1,
      "message": "have a look at FileReftableDatabase::addReftable\n\nA ref update in repo1 causes the tables.list to updated, so repo2 has an outdated view and will fail any write that is applied. If this happens, the update fails, but tables.list is reloaded. So the 2nd try goes through.\n\nin the loose files storage, such changes can run concurrently.\n\nif you were writing the same branch, you would always have a failure, regardless of backend.",
      "parentUuid": "0679ea8a_ed211662",
      "range": {
        "startLine": 108,
        "startChar": 0,
        "endLine": 115,
        "endChar": 34
      },
      "revId": "38586d54d0a2da26d574fec831fce8964205db50",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8571ebc2_bcaf8553",
        "filename": "org.eclipse.jgit.test/tst/org/eclipse/jgit/internal/storage/file/FileReftableTest.java",
        "patchSetId": 92
      },
      "lineNbr": 115,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-01-24T18:10:58Z",
      "side": 1,
      "message": "\u003e have a look at FileReftableDatabase::addReftable\n\u003e \n\u003e A ref update in repo1 causes the tables.list to updated, so repo2 has an outdated view and will fail any write that is applied.\n\nI understand it better now, thanks. Do you believe that the retry should be implicit in the update() though?\nAlso, what if you did not perform an update() but simply a read of an outdated ref, then it would not fail and the data returned would be stale.\n\n\u003e If this happens, the update fails, but tables.list is reloaded. So the 2nd try goes through.\n\u003e \n\u003e in the loose files storage, such changes can run concurrently.\n\nI see, but it seems that you are testing the internal implementation details of what the current implementation of ref-table does, rather than testing what an external user should see from a ref-database.\n\n\u003e if you were writing the same branch, you would always have a failure, regardless of backend.\n\nMakes sense. Thanks for clarifying it.",
      "parentUuid": "b1e970b4_40099651",
      "range": {
        "startLine": 108,
        "startChar": 0,
        "endLine": 115,
        "endChar": 34
      },
      "revId": "38586d54d0a2da26d574fec831fce8964205db50",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "922602ad_0be200f1",
        "filename": "org.eclipse.jgit.test/tst/org/eclipse/jgit/internal/storage/file/FileReftableTest.java",
        "patchSetId": 92
      },
      "lineNbr": 115,
      "author": {
        "id": 1007980
      },
      "writtenOn": "2025-01-25T15:55:23Z",
      "side": 1,
      "message": "\u003eAlso, what if you did not perform an update() but simply a read of an outdated ref, then it would not fail and the data \u003ereturned would be stale.\n\nref updates are usually part of a transaction, where  you read the database at a fixed timestamp, create an update based on what you read, and then try to commit it. If the intervening update changed what you read, the transaction would no longer be valid and should be redone as a whole.\n\nReading stale data is a fact of life in any system that allows concurrent access.\n\n\u003eI see, but it seems that you are testing the internal implementation details of what the current implementation of ref-table does, rather than testing what an external user should see from a ref-database.\n\nIt is testing code that was written. \n\nInstead of complaining, why don\u0027t you say what your real problem is?\n\nNote that the CGit reftable code was originally inspired by this code. There have been several performance fixes to it since it was committed into CGit.",
      "parentUuid": "8571ebc2_bcaf8553",
      "range": {
        "startLine": 108,
        "startChar": 0,
        "endLine": 115,
        "endChar": 34
      },
      "revId": "38586d54d0a2da26d574fec831fce8964205db50",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7aebfd1d_48b627ba",
        "filename": "org.eclipse.jgit.test/tst/org/eclipse/jgit/internal/storage/file/FileReftableTest.java",
        "patchSetId": 92
      },
      "lineNbr": 115,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-01-25T19:20:14Z",
      "side": 1,
      "message": "\u003e \u003eAlso, what if you did not perform an update() but simply a read of an outdated ref, then it would not fail and the data \u003ereturned would be stale.\n\u003e \n\u003e ref updates are usually part of a transaction, where  you read the database at a fixed timestamp, create an update based on what you read, and then try to commit it. If the intervening update changed what you read, the transaction would no longer be valid and should be redone as a whole.\n\nMakes sense, when there is a ref-update involved.\n\n\u003e Reading stale data is a fact of life in any system that allows concurrent access.\n\nSure, every variable read is stale by definition after the read operation.\n\n\u003e \u003eI see, but it seems that you are testing the internal implementation details of what the current implementation of ref-table does, rather than testing what an external user should see from a ref-database.\n\u003e \n\u003e It is testing code that was written. \n\nYep, that\u0027s what I thought: it\u0027s a white-box testing.\n\n\u003e Instead of complaining, why don\u0027t you say what your real problem is?\n\nApologies if my tone was perceived as a complaint: the intent of the test was not clear to me and that\u0027s why I commented on the change. It isn\u0027t a complaint.\n\nThe Issue jgit-102 was raised (https://github.com/eclipse-jgit/jgit/issues/102) on ref-table not being able to detect changes on the underlying filesystem, which I believe it is expected as the refresh is done upon updates. If the update happened outside of the ref-table code, then it won\u0027t be seen.\n\nMatthias has drafted a fix with Change 1206683 (https://eclipse.gerrithub.io/c/eclipse-jgit/jgit/+/1206683) which breaks this test and I was trying to understand if that was because an external expected functionality would break or if this was just a white-box testing which is expected to break once the implementation changes.\n\n\u003e Note that the CGit reftable code was originally inspired by this code. There have been several performance fixes to it since it was committed into CGit.\n\nI have noticed a lot of different behaviour between CGit reftable and JGit, as it is largely expected as the CGit one is relatively new. I tried to run a simple test using both together and ended up with a corrupted repository very quickly :-(",
      "parentUuid": "922602ad_0be200f1",
      "range": {
        "startLine": 108,
        "startChar": 0,
        "endLine": 115,
        "endChar": 34
      },
      "revId": "38586d54d0a2da26d574fec831fce8964205db50",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bfe21477_9d89705d",
        "filename": "org.eclipse.jgit.test/tst/org/eclipse/jgit/internal/storage/file/FileReftableTest.java",
        "patchSetId": 92
      },
      "lineNbr": 115,
      "author": {
        "id": 1007980
      },
      "writtenOn": "2025-01-26T10:47:45Z",
      "side": 1,
      "message": "\u003e Matthias has drafted a fix with Change 1206683 (https://eclipse.gerrithub.io/c/eclipse-jgit/jgit/+/1206683) which breaks this test and I was trying to understand if that was because an external expected functionality would break or if this was just a white-box testing which is expected to break once the implementation changes.\n\nI don\u0027t think the bugreport is a bug per se. The 2nd read is delivering the value it read when it took the snapshot. What does JGit promise about how things are supposed to work? As discussed, exactRef can always return a stale data. If the reporter has expectations about ordering, they should use synchronization mechanism to disambiguate how stale they allow their data to be.\n\nBy rereading the DB at random in a exactRef() and friends, you make it impossible for anyone to build a system that creates consistent transactions (reader runs the risk of seeing a frankenstein of snapshot versions when doing the reads.) \n\nIn general, that may not be a big deal, but since you are in the business of building databases on top of git (NoteDB), that sounds like a risky tradeoff to make. (Also it inserts a disk read in a potentially hot code path; not great for performance)\n\n\u003e I tried to run a simple test using both together and ended up with a corrupted repository very quickly :-(\n\nI\u0027m sorry to hear that. AFAIK, there was no incompatiblity in storage format, so that should not happen. Do you have a reproducible scenario?",
      "parentUuid": "7aebfd1d_48b627ba",
      "range": {
        "startLine": 108,
        "startChar": 0,
        "endLine": 115,
        "endChar": 34
      },
      "revId": "38586d54d0a2da26d574fec831fce8964205db50",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "61e22d5b_75dfce85",
        "filename": "org.eclipse.jgit.test/tst/org/eclipse/jgit/internal/storage/file/FileReftableTest.java",
        "patchSetId": 92
      },
      "lineNbr": 115,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-01-26T11:07:20Z",
      "side": 1,
      "message": "\u003e \u003e Matthias has drafted a fix with Change 1206683 (https://eclipse.gerrithub.io/c/eclipse-jgit/jgit/+/1206683) which breaks this test and I was trying to understand if that was because an external expected functionality would break or if this was just a white-box testing which is expected to break once the implementation changes.\n\u003e \n\u003e I don\u0027t think the bugreport is a bug per se. The 2nd read is delivering the value it read when it took the snapshot. What does JGit promise about how things are supposed to work? As discussed, exactRef can always return a stale data. \n\nYes, it is specifically mentioned in the \"readers contract\" of the RefTable specs at https://git-scm.com/docs/reftable#_readers.\n\n\u003e By rereading the DB at random in a exactRef() and friends, you make it impossible for anyone to build a system that creates consistent transactions (reader runs the risk of seeing a frankenstein of snapshot versions when doing the reads.) \n\nI see the point and I do agree: consistency is key and RefTable allows to bring a consistent snapshot of _how the refs where at some point in time_ as a whole. That\u0027s a huge plus if you are wishing to make a consistent update.\n\n\u003e In general, that may not be a big deal, but since you are in the business of building databases on top of git (NoteDB), that sounds like a risky tradeoff to make. (Also it inserts a disk read in a potentially hot code path; not great for performance)\n\nUnderstood and fully agreed.\n\nI believe JGit\u0027s `RepositoryCache` should be disabled when using RefTable because it would risk to have a snapshot which is left opened _indefinitely_. Think about a Gerrit replica where you never ever serve updates: the snapshot will be read at the very beginning when Gerrit starts and never closed, which means nobody would ever see any updates on those refs served from the replicas.\n\n\u003e \u003e I tried to run a simple test using both together and ended up with a corrupted repository very quickly :-(\n\u003e \n\u003e I\u0027m sorry to hear that. AFAIK, there was no incompatiblity in storage format, so that should not happen. Do you have a reproducible scenario?\n\nSure, will file a separate bug on CGit (and possibly also propose a fix?). Running everything with JGit never broke anything.",
      "parentUuid": "bfe21477_9d89705d",
      "range": {
        "startLine": 108,
        "startChar": 0,
        "endLine": 115,
        "endChar": 34
      },
      "revId": "38586d54d0a2da26d574fec831fce8964205db50",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "684a9d1c_198a52ec",
        "filename": "org.eclipse.jgit.test/tst/org/eclipse/jgit/internal/storage/file/FileReftableTest.java",
        "patchSetId": 92
      },
      "lineNbr": 115,
      "author": {
        "id": 1007980
      },
      "writtenOn": "2025-01-26T11:49:48Z",
      "side": 1,
      "message": "\u003e Yes, it is specifically mentioned in the \"readers contract\" of the RefTable specs at https://git-scm.com/docs/reftable#_readers.\n\nThe question is what JGit promised about this before. If it make the promises that you always get the state on disk at the moment of exactRef(), then you\u0027ll have to honor this, and devise a special mode for \u0027consistent snapshot read\u0027 that turns off implicit rereads.\n\n\n\u003e I believe JGit\u0027s RepositoryCache should be disabled when using RefTable because it would risk to have a snapshot which is left opened indefinitely\n\nthat may create other performance problems. Why not drop the reftable cache when you hand out a cached copy?\n\n\u003e Sure, will file a separate bug on CGit (and possibly also propose a fix?). \n\nif you want me to opine, CC me directly. I don\u0027t keep track of JGit or CGit these days.",
      "parentUuid": "61e22d5b_75dfce85",
      "range": {
        "startLine": 108,
        "startChar": 0,
        "endLine": 115,
        "endChar": 34
      },
      "revId": "38586d54d0a2da26d574fec831fce8964205db50",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bdcd928b_a4b35b36",
        "filename": "org.eclipse.jgit.test/tst/org/eclipse/jgit/internal/storage/file/FileReftableTest.java",
        "patchSetId": 92
      },
      "lineNbr": 115,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-01-27T16:45:43Z",
      "side": 1,
      "message": "I discovered at the end that it was a problem with Gerrit reference counting and the RepositoryCache: fixed in Gerrit with https://gerrit-review.googlesource.com/c/gerrit/+/449083 and the problem has just disappeared ðŸŽ‰\n\nI can see changes on the repository that are coming from CGit. I\u0027ll file a separate bug about the corruption.\n\nI was wrong about the RepositoryCache: there is no need to disable it. If the reference counting works (now with https://gerrit-review.googlesource.com/c/gerrit/+/449083, it does work), the mostly used repos are reused and released when unused.\n\nBecause JGit\u0027s ref-table refreshes on updates, all changes made within Gerrit are automatically detected. Changes from outside Gerrit are detected either upon update or when the cache expires, which is what you would expect from a cache to behave.",
      "parentUuid": "684a9d1c_198a52ec",
      "range": {
        "startLine": 108,
        "startChar": 0,
        "endLine": 115,
        "endChar": 34
      },
      "revId": "38586d54d0a2da26d574fec831fce8964205db50",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    }
  ]
}