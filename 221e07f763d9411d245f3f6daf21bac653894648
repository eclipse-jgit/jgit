{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "12aef072_500b54e0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 12
      },
      "lineNbr": 12,
      "author": {
        "id": 1022030
      },
      "writtenOn": "2025-05-13T22:48:55Z",
      "side": 1,
      "message": "This isn\u0027t true. The loose ref is locked in `org.eclipse.jgit.lib.RefUpdate#updateImpl()`",
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fd9ee10b_46178017",
        "filename": "/COMMIT_MSG",
        "patchSetId": 12
      },
      "lineNbr": 12,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-05-14T07:51:38Z",
      "side": 1,
      "message": "```suggestion\nHowever, loose refs are not locked during the construction of the packed-refs but only upon deletion, this can create\n```",
      "range": {
        "startLine": 12,
        "startChar": 9,
        "endLine": 12,
        "endChar": 52
      },
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c0c5d319_3a8f117e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 12
      },
      "lineNbr": 12,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-05-14T07:51:38Z",
      "side": 1,
      "message": "+1",
      "parentUuid": "12aef072_500b54e0",
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "45a0cbc9_a9e1686a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 12
      },
      "lineNbr": 12,
      "author": {
        "id": 1020677
      },
      "writtenOn": "2025-05-14T10:35:19Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c0c5d319_3a8f117e",
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fa6b8afc_62703c33",
        "filename": "/COMMIT_MSG",
        "patchSetId": 12
      },
      "lineNbr": 12,
      "author": {
        "id": 1020677
      },
      "writtenOn": "2025-05-14T10:35:19Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "fd9ee10b_46178017",
      "range": {
        "startLine": 12,
        "startChar": 9,
        "endLine": 12,
        "endChar": 52
      },
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0a51f1b9_d2ae4810",
        "filename": "/COMMIT_MSG",
        "patchSetId": 12
      },
      "lineNbr": 13,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-05-13T07:10:24Z",
      "side": 1,
      "message": "That\u0027s not the issue described in jgit-152: the ref *must* exist as a loose ref, then not triggering any locking on the packed-refs at all.\n\nThen a concurrent pack refs may include the loose ref in the newly created packed ref whilst the loose ref deletion is taking place, causing the ref to be _\"resumed\"_ after being deleted.",
      "range": {
        "startLine": 13,
        "startChar": 18,
        "endLine": 13,
        "endChar": 48
      },
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3256a04b_ac44143a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 12
      },
      "lineNbr": 13,
      "author": {
        "id": 1020677
      },
      "writtenOn": "2025-05-14T10:55:03Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "0a51f1b9_d2ae4810",
      "range": {
        "startLine": 13,
        "startChar": 18,
        "endLine": 13,
        "endChar": 48
      },
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "90192df2_088abd85",
        "filename": "/COMMIT_MSG",
        "patchSetId": 12
      },
      "lineNbr": 16,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-05-13T07:10:24Z",
      "side": 1,
      "message": "deletion",
      "range": {
        "startLine": 16,
        "startChar": 0,
        "endLine": 16,
        "endChar": 8
      },
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "29e63b52_e8daddc6",
        "filename": "/COMMIT_MSG",
        "patchSetId": 12
      },
      "lineNbr": 16,
      "author": {
        "id": 1020677
      },
      "writtenOn": "2025-05-14T10:35:19Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "90192df2_088abd85",
      "range": {
        "startLine": 16,
        "startChar": 0,
        "endLine": 16,
        "endChar": 8
      },
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a5691cf7_01f231a9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 12
      },
      "lineNbr": 20,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-05-13T07:10:24Z",
      "side": 1,
      "message": "That\u0027s not true: the list of refs can still increase, which is fine because loose refs override packed refs. However, this change assures that there cannot be loose refs deletions whilst the packing of the refs takes place.",
      "range": {
        "startLine": 19,
        "startChar": 58,
        "endLine": 20,
        "endChar": 10
      },
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d3c61c47_c52ec1cf",
        "filename": "/COMMIT_MSG",
        "patchSetId": 12
      },
      "lineNbr": 20,
      "author": {
        "id": 1020677
      },
      "writtenOn": "2025-05-14T10:55:03Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a5691cf7_01f231a9",
      "range": {
        "startLine": 19,
        "startChar": 58,
        "endLine": 20,
        "endChar": 10
      },
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "55d6bad6_24ef6674",
        "filename": "/COMMIT_MSG",
        "patchSetId": 12
      },
      "lineNbr": 21,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-05-13T07:10:24Z",
      "side": 1,
      "message": "You should also add that this fixes an issue happening *ONLY* when a repository contains a large number of refs (500k or more) and therefore the packing of the refs is _slow enough_ for a loose ref deletion to _sneak in_ during the packing process.",
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4075adf6_6cd80041",
        "filename": "/COMMIT_MSG",
        "patchSetId": 12
      },
      "lineNbr": 21,
      "author": {
        "id": 1020677
      },
      "writtenOn": "2025-05-14T10:55:03Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "55d6bad6_24ef6674",
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "86acba5d_74a11bfa",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 12
      },
      "lineNbr": 684,
      "author": {
        "id": 1022030
      },
      "writtenOn": "2025-05-13T22:47:41Z",
      "side": 1,
      "message": "This new version doesn\u0027t look correct to me. I think the base is mostly correct, except that it 1) releases the packed-refs lock too early and 2) it does the loose ref deletion too late. I think you want this:\n\nPre-req:\n* move base lines 703-716 into a new helper method `deleteLooseRefAndLogs()`\n\nIn this `delete()` method:\n0. lock the loose ref (this is done by the caller already, even if there is no loose ref)\n1. do the same \"check if this ref is packed and lock packed-refs\" logic from base lines 684-688\n2. while holding that packed-refs lock, call the new `deleteLooseRefAndLogs()` method\n  * you could do this immediately after `lockPackedRefsOrThrow()` or wait until inside the finally block before calling `unlock()`. Earlier is probably better so that another caller can create a new loose ref with this same name race-free, but without waiting for the packed-refs file to be written.\n3. if the ref wasn\u0027t in packed-refs, have an else block that calls the new `deleteLooseRefAndLogs()` method",
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ae7ffda0_e3422da8",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 12
      },
      "lineNbr": 684,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-05-14T07:51:38Z",
      "side": 1,
      "message": "\u003e 3. if the ref wasn\u0027t in packed-refs, have an else block that calls the new `deleteLooseRefAndLogs()` method\n\nEven if the ref isn\u0027t in the `packed-refs` file, it should still lock for preventing concurrent packing of refs and deletion of loose refs, which caused the issue https://github.com/eclipse-jgit/jgit/issues/152.\n\nWe should also look at how the C implementation of `git` does the deletion of loose refs, as I\u0027ve noticed that it also locks the `packed-refs` even if the ref is loose.",
      "parentUuid": "86acba5d_74a11bfa",
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    }
  ]
}