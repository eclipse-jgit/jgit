{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "12aef072_500b54e0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 12
      },
      "lineNbr": 12,
      "author": {
        "id": 1022030
      },
      "writtenOn": "2025-05-13T22:48:55Z",
      "side": 1,
      "message": "This isn\u0027t true. The loose ref is locked in `org.eclipse.jgit.lib.RefUpdate#updateImpl()`",
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fd9ee10b_46178017",
        "filename": "/COMMIT_MSG",
        "patchSetId": 12
      },
      "lineNbr": 12,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-05-14T07:51:38Z",
      "side": 1,
      "message": "```suggestion\nHowever, loose refs are not locked during the construction of the packed-refs but only upon deletion, this can create\n```",
      "range": {
        "startLine": 12,
        "startChar": 9,
        "endLine": 12,
        "endChar": 52
      },
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c0c5d319_3a8f117e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 12
      },
      "lineNbr": 12,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-05-14T07:51:38Z",
      "side": 1,
      "message": "+1",
      "parentUuid": "12aef072_500b54e0",
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "45a0cbc9_a9e1686a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 12
      },
      "lineNbr": 12,
      "author": {
        "id": 1020677
      },
      "writtenOn": "2025-05-14T10:35:19Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c0c5d319_3a8f117e",
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fa6b8afc_62703c33",
        "filename": "/COMMIT_MSG",
        "patchSetId": 12
      },
      "lineNbr": 12,
      "author": {
        "id": 1020677
      },
      "writtenOn": "2025-05-14T10:35:19Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "fd9ee10b_46178017",
      "range": {
        "startLine": 12,
        "startChar": 9,
        "endLine": 12,
        "endChar": 52
      },
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0a51f1b9_d2ae4810",
        "filename": "/COMMIT_MSG",
        "patchSetId": 12
      },
      "lineNbr": 13,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-05-13T07:10:24Z",
      "side": 1,
      "message": "That\u0027s not the issue described in jgit-152: the ref *must* exist as a loose ref, then not triggering any locking on the packed-refs at all.\n\nThen a concurrent pack refs may include the loose ref in the newly created packed ref whilst the loose ref deletion is taking place, causing the ref to be _\"resumed\"_ after being deleted.",
      "range": {
        "startLine": 13,
        "startChar": 18,
        "endLine": 13,
        "endChar": 48
      },
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3256a04b_ac44143a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 12
      },
      "lineNbr": 13,
      "author": {
        "id": 1020677
      },
      "writtenOn": "2025-05-14T10:55:03Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "0a51f1b9_d2ae4810",
      "range": {
        "startLine": 13,
        "startChar": 18,
        "endLine": 13,
        "endChar": 48
      },
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "90192df2_088abd85",
        "filename": "/COMMIT_MSG",
        "patchSetId": 12
      },
      "lineNbr": 16,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-05-13T07:10:24Z",
      "side": 1,
      "message": "deletion",
      "range": {
        "startLine": 16,
        "startChar": 0,
        "endLine": 16,
        "endChar": 8
      },
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "29e63b52_e8daddc6",
        "filename": "/COMMIT_MSG",
        "patchSetId": 12
      },
      "lineNbr": 16,
      "author": {
        "id": 1020677
      },
      "writtenOn": "2025-05-14T10:35:19Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "90192df2_088abd85",
      "range": {
        "startLine": 16,
        "startChar": 0,
        "endLine": 16,
        "endChar": 8
      },
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a5691cf7_01f231a9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 12
      },
      "lineNbr": 20,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-05-13T07:10:24Z",
      "side": 1,
      "message": "That\u0027s not true: the list of refs can still increase, which is fine because loose refs override packed refs. However, this change assures that there cannot be loose refs deletions whilst the packing of the refs takes place.",
      "range": {
        "startLine": 19,
        "startChar": 58,
        "endLine": 20,
        "endChar": 10
      },
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d3c61c47_c52ec1cf",
        "filename": "/COMMIT_MSG",
        "patchSetId": 12
      },
      "lineNbr": 20,
      "author": {
        "id": 1020677
      },
      "writtenOn": "2025-05-14T10:55:03Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a5691cf7_01f231a9",
      "range": {
        "startLine": 19,
        "startChar": 58,
        "endLine": 20,
        "endChar": 10
      },
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "55d6bad6_24ef6674",
        "filename": "/COMMIT_MSG",
        "patchSetId": 12
      },
      "lineNbr": 21,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-05-13T07:10:24Z",
      "side": 1,
      "message": "You should also add that this fixes an issue happening *ONLY* when a repository contains a large number of refs (500k or more) and therefore the packing of the refs is _slow enough_ for a loose ref deletion to _sneak in_ during the packing process.",
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4075adf6_6cd80041",
        "filename": "/COMMIT_MSG",
        "patchSetId": 12
      },
      "lineNbr": 21,
      "author": {
        "id": 1020677
      },
      "writtenOn": "2025-05-14T10:55:03Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "55d6bad6_24ef6674",
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "86acba5d_74a11bfa",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 12
      },
      "lineNbr": 684,
      "author": {
        "id": 1022030
      },
      "writtenOn": "2025-05-13T22:47:41Z",
      "side": 1,
      "message": "This new version doesn\u0027t look correct to me. I think the base is mostly correct, except that it 1) releases the packed-refs lock too early and 2) it does the loose ref deletion too late. I think you want this:\n\nPre-req:\n* move base lines 703-716 into a new helper method `deleteLooseRefAndLogs()`\n\nIn this `delete()` method:\n0. lock the loose ref (this is done by the caller already, even if there is no loose ref)\n1. do the same \"check if this ref is packed and lock packed-refs\" logic from base lines 684-688\n2. while holding that packed-refs lock, call the new `deleteLooseRefAndLogs()` method\n  * you could do this immediately after `lockPackedRefsOrThrow()` or wait until inside the finally block before calling `unlock()`. Earlier is probably better so that another caller can create a new loose ref with this same name race-free, but without waiting for the packed-refs file to be written.\n3. if the ref wasn\u0027t in packed-refs, have an else block that calls the new `deleteLooseRefAndLogs()` method",
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ae7ffda0_e3422da8",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 12
      },
      "lineNbr": 684,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-05-14T07:51:38Z",
      "side": 1,
      "message": "\u003e 3. if the ref wasn\u0027t in packed-refs, have an else block that calls the new `deleteLooseRefAndLogs()` method\n\nEven if the ref isn\u0027t in the `packed-refs` file, it should still lock for preventing concurrent packing of refs and deletion of loose refs, which caused the issue https://github.com/eclipse-jgit/jgit/issues/152.\n\nWe should also look at how the C implementation of `git` does the deletion of loose refs, as I\u0027ve noticed that it also locks the `packed-refs` even if the ref is loose.",
      "parentUuid": "86acba5d_74a11bfa",
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9a2d921c_c0b11e2c",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 12
      },
      "lineNbr": 684,
      "author": {
        "id": 1020677
      },
      "writtenOn": "2025-05-14T10:58:03Z",
      "side": 1,
      "message": "Turns out that `check if this ref is packed and lock packed-refs` currently doesn\u0027t do what you\u0027d expect it to do. I\u0027ve tried explaining it in the commit message, but essentially we need to use the refreshed version of packed-refs before doing anything. This has the benefit that we only read the packed ref at most once(rather than twice).\n\nIt does mean that we need to lock before checking if the file contains the ref or not.",
      "parentUuid": "ae7ffda0_e3422da8",
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1b2b291b_7f61802e",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 12
      },
      "lineNbr": 684,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-05-14T13:51:02Z",
      "side": 1,
      "message": "😎 finding @danielesassoli@gmail.com, so basically, we were *NOT* removing the ref from the packed file just because we did not even realise it was there, due to the use of a cached copy of the packed-refs.",
      "parentUuid": "9a2d921c_c0b11e2c",
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d6603042_4a92773f",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 12
      },
      "lineNbr": 684,
      "author": {
        "id": 1022030
      },
      "writtenOn": "2025-05-14T15:37:14Z",
      "side": 1,
      "message": "\u003e Even if the ref isn\u0027t in the packed-refs file, it should still lock for preventing concurrent packing of refs and deletion of loose refs, which caused the issue https://github.com/eclipse-jgit/jgit/issues/152.\n\nNo, I think that fix is needed in pack-refs, not in this delete code. It\u0027s a problem with pack-refs including the wrong content in packed-refs, not a problem with deleting the ref. Specifically, I think that fix is the one I outlined in [my inline comment](https://eclipse.gerrithub.io/c/eclipse-jgit/jgit/+/1176274/comment/85ae4029_0ff96036/) that\u0027s also referenced in issue 152.\n\n\u003e due to the use of a cached copy of the packed-refs\n\nAs I noted in my comment on the commit message, if this is happening, then I think it points to either 1) you have your `trustPackedRefsStat` setting configured incorrectly or 2) there\u0027s a bug in `getPackedRefs()`.",
      "parentUuid": "1b2b291b_7f61802e",
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "533c90ae_8619f330",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 12
      },
      "lineNbr": 684,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-05-14T18:31:18Z",
      "side": 1,
      "message": "Yes, I believe we need input from @danielesassoli@gmail.com as we need to understand why the latest packed refs wasn\u0027t visible to the delete in your case.",
      "parentUuid": "d6603042_4a92773f",
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "11892759_ac1624d8",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 12
      },
      "lineNbr": 684,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-05-14T19:45:31Z",
      "side": 1,
      "message": "I believe I found the root cause, and it looks this is caused by the use of the `SnapshottingRefDirectory`.\n\nSee the `getPackedRef()` implementation here below:\n\n```\n\t@Override\n\tPackedRefList getPackedRefs() throws IOException {\n\t\tif (!isValid) {\n\t\t\tsynchronized (this) {\n\t\t\t\tif (!isValid) {\n\t\t\t\t\trefreshSnapshot();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn packedRefs.get();\n\t}\n```\n\nThere is no check for any update on disk, because it works on an in-memory snapshot, hence it will never check if the data has changed.",
      "parentUuid": "533c90ae_8619f330",
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "09b3e837_94fd0762",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 12
      },
      "lineNbr": 684,
      "author": {
        "id": 1022030
      },
      "writtenOn": "2025-05-14T20:12:11Z",
      "side": 1,
      "message": "\u003e I believe I found the root cause, and it looks this is caused by the use of the `SnapshottingRefDirectory`.\n\n[snip]\n\n\u003e There is no check for any update on disk, because it works on an in-memory snapshot, hence it will never check if the data has changed.\n\nYes, but you need to look at the `delete()` override in that class too:\n```\nvoid delete(RefDirectoryUpdate update) throws IOException {\n    refreshSnapshot();\n    super.delete(update);\n}\n```\n\nThat does an explicit refresh, so I don\u0027t think there\u0027s a staleness issue.",
      "parentUuid": "11892759_ac1624d8",
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d5c5a620_b2ef4d1f",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 12
      },
      "lineNbr": 684,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-05-14T21:03:05Z",
      "side": 1,
      "message": "\u003e That does an explicit refresh, so I don\u0027t think there\u0027s a staleness issue.\n\nI also believe that @danielesassoli@gmail.com is just mixing things up: his use of the snapshotting ref directory was accidental, and this change should not try to fix staleness.\n\n@danielesassoli@gmail.com can you repeat the tests *without* using the `SnapshottingRefDirectory` ?",
      "parentUuid": "09b3e837_94fd0762",
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e687b4e5_498a4293",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 12
      },
      "lineNbr": 684,
      "author": {
        "id": 1020677
      },
      "writtenOn": "2025-05-15T08:42:23Z",
      "side": 1,
      "message": "Right so, thanks for the feedback everyone. Setting `core.usePerRequestRefCache\u003dfalse` in my gerrit.config meant that now `getPackedRefs` returns the latest state of the patchset, which means we can leave the structure of the code as is. We just need to lock the packed ref before the if statement, which logically makes sense to me and its also what they do in cgit, from what I understand.\n\nWether this points to a problem with `core.usePerRequestRefCache` might be a topic for another conversation.",
      "parentUuid": "d5c5a620_b2ef4d1f",
      "revId": "221e07f763d9411d245f3f6daf21bac653894648",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    }
  ]
}