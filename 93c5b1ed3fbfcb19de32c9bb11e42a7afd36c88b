{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "2cb22e10_17add618",
        "filename": "org.eclipse.jgit.benchmarks/src/org/eclipse/jgit/benchmarks/DateRevQueueBenchmark.java",
        "patchSetId": 27
      },
      "lineNbr": 104,
      "author": {
        "id": 1000671
      },
      "writtenOn": "2024-01-07T11:27:41Z",
      "side": 1,
      "message": "I found the issue with this benchmark, you generate numCommits commits in the setupBenchmark method but here you keep adding commits randomly picked from the bounded commits array containing numCommits. Hence you end up adding commits until the configured time of 10 seconds is reached. This means the queue grows much bigger than what you think and the numbers are rather meaningless. When increasing iterations to 10 the new implementation always crashes with OOM since it\u0027s faster than the old one and hence the queue is growing faster.\n\nTo limit the max size of the queue I added the following method which is executed after each invocation of the test method:\n\n```\n@TearDown(Level.Invocation)\npublic void check() {\n\tif (++count \u003d\u003d numCommits) {\n\t\tcount \u003d 0;\n\t\tqueue \u003d new DateRevQueue(false);\n\t}\n}\n```\n\nand instead of generating synthetic commits I altered the setup method to use commits from an already existing real repo:\n\n```\ncommits \u003d new RevCommit[numCommits];\nGit git \u003d Git.open(new File(\"repo/path\"));\nRepository repo \u003d git.getRepository();\ntry (RevWalk rw \u003d new RevWalk(repo)) {\n\tfor (Ref r : repo.getRefDatabase().getRefs()) {\n\t\tRevObject ro \u003d rw.peel(rw.parseAny(r.getObjectId()));\n\t\tif (!(ro instanceof RevCommit)) {\n\t\t\tcontinue;\n\t\t}\n\t\trw.markStart((RevCommit) ro);\n\t}\n\trepo.exactRef(\"refs/heads/master\").getObjectId()));\n\tfor (int i \u003d 0; i \u003c numCommits; i++) {\n\t\tcommits[i] \u003d rw.next();\n\t}\n}\nqueue \u003d new DateRevQueue(false);\n```\nI used our largest repo with \u003e20 mio commits, enabled profiling using JFR and got the following numbers using this command to run the benchmark:\n`java -jar ./target/benchmarks.jar DateRevQueueBenchmark -jvmArgs \u0027-Xmx16g\u0027 -f 1 -prof jfr`\n\n\nold implementation\n```\nBenchmark                                    (numCommits)  Mode  Cnt   Score    Error  Units    add     buildIndex\nDateRevQueueBenchmark.testDataRevQueue               1000  avgt    5   0,468 ±  0,005  us/op    94,3%    0,0%\nDateRevQueueBenchmark.testDataRevQueue               5000  avgt    5   0,276 ±  0,011  us/op    80,0%    1,5%\nDateRevQueueBenchmark.testDataRevQueue              10000  avgt    5   0,323 ±  0,013  us/op    74,2%    5,1%\nDateRevQueueBenchmark.testDataRevQueue              50000  avgt    5   0,568 ±  0,034  us/op    57,2%   23,2%\nDateRevQueueBenchmark.testDataRevQueue             100000  avgt    5   0,848 ±  0,083  us/op    49,3%   33,0%\nDateRevQueueBenchmark.testDataRevQueue             500000  avgt    5   4,956 ±  0,325  us/op    17,6%   73,9%\nDateRevQueueBenchmark.testDataRevQueue            1000000  avgt    5  15,902 ± 25,453  us/op    10,1%   85,5%\nDateRevQueueBenchmark.testDataRevQueue            5000000  avgt    5  50,852 ± 98,362  us/op     5,4%   91,7%\nDateRevQueueBenchmark.testDataRevQueue           10000000  avgt    5  48,062 ± 97,302  us/op     5,9%   91,6%\n```\nthe numbers above 500000 commits are questionable, std dev goes through the roof.\nProfiling shows that at small number of commits performance is dominated by DateRevQueue\u0027s add method, starting around 500000 commits it\u0027s dominated by rebuilding the index every 1000 commits.\n\n\nnew implementation\n```\nBenchmark                                    (numCommits)  Mode  Cnt  Score   Error  Units    Integer.compare   RevCommitEntry.init\nDateRevQueueBenchmark.testDataRevQueue               1000  avgt    5  0,040 ± 0,002  us/op    37,2%             7,9%\nDateRevQueueBenchmark.testDataRevQueue               5000  avgt    5  0,042 ± 0,002  us/op    43,3%             5,8%\nDateRevQueueBenchmark.testDataRevQueue              10000  avgt    5  0,042 ± 0,002  us/op    46,9%\nDateRevQueueBenchmark.testDataRevQueue              50000  avgt    5  0,050 ± 0,001  us/op    61,4%             3,8%\nDateRevQueueBenchmark.testDataRevQueue             100000  avgt    5  0,064 ± 0,014  us/op    70,1%             2,8%\nDateRevQueueBenchmark.testDataRevQueue             500000  avgt    5  0,105 ± 0,005  us/op    85,0%             2,3%\nDateRevQueueBenchmark.testDataRevQueue            1000000  avgt    5  0,141 ± 0,013  us/op    86,6%             1,9%\nDateRevQueueBenchmark.testDataRevQueue            5000000  avgt    5  0,195 ± 0,037  us/op    89,7%             1,2%\nDateRevQueueBenchmark.testDataRevQueue           10000000  avgt    5  0,220 ± 0,038  us/op    90,6%             1,5%\n```\nwhen using PriorityQueue performance is dominated by comparing integers used for sorting.",
      "revId": "93c5b1ed3fbfcb19de32c9bb11e42a7afd36c88b",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    }
  ]
}