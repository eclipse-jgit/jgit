{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "0c03f8d4_aea59ede",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 34,
      "author": {
        "id": 1022030
      },
      "writtenOn": "2023-12-07T05:24:18Z",
      "side": 1,
      "message": "The loose ref should be locked during this entire time too. Where do you see that it\u0027s not?",
      "range": {
        "startLine": 34,
        "startChar": 0,
        "endLine": 34,
        "endChar": 51
      },
      "revId": "25e5fb56f110faf03163031d53b1953aa2974378",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d5111141_6a51f691",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 34,
      "author": {
        "id": 1022030
      },
      "writtenOn": "2023-12-07T05:54:23Z",
      "side": 1,
      "message": "Sorry, never mind, it\u0027s clearly not, but shouldn\u0027t need to be since a loose ref always has precedence anyway. General mutability of loose refs isn\u0027t a problem, but I commented inline on what could be.",
      "parentUuid": "0c03f8d4_aea59ede",
      "range": {
        "startLine": 34,
        "startChar": 0,
        "endLine": 34,
        "endChar": 51
      },
      "revId": "25e5fb56f110faf03163031d53b1953aa2974378",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "810c8abb_2a5baed2",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 4
      },
      "lineNbr": 811,
      "author": {
        "id": 1022030
      },
      "writtenOn": "2023-12-07T05:54:23Z",
      "side": 1,
      "message": "Hmm. This wouldn\u0027t be your problem, but I wonder if there\u0027s a race with loose ref deletion here. If there\u0027s a loose ref that\u0027s not in packed-refs, then when we delete, we don\u0027t lock packed-refs. That means that ref packing running concurrently to the delete could \"undo\" the delete by persisting the previous loose ref value into packed-refs.\n\nOff the top of my head I can think of two ways to solve it: 1) always lock packed-refs for deletes, and 2) if we keep the packed-refs lock through this point, we know no other process will have persisted the loose ref into it so we could update our copy of newPacked and write packed-refs again (or delay doing so until after this point).",
      "range": {
        "startLine": 811,
        "startChar": 10,
        "endLine": 811,
        "endChar": 33
      },
      "revId": "25e5fb56f110faf03163031d53b1953aa2974378",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f128a890_e74ba411",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 4
      },
      "lineNbr": 811,
      "author": {
        "id": 1012541
      },
      "writtenOn": "2023-12-07T11:53:49Z",
      "side": 1,
      "message": "\u003e  This wouldn\u0027t be your problem, but I wonder if there\u0027s a race with loose ref deletion here.\n\nYep it doesn\u0027t look like my problem.\n\n\u003e Off the top of my head I can think of two ways to solve it: 1) always lock packed-refs for deletes, and 2) if we keep the packed-refs lock through this point, we know no other process will have persisted the loose ref into it so we could update our copy of newPacked and write packed-refs again (or delay doing so until after this point).\n\nThe packed-ref lock is released at L839. So ti should still be locked here. Or am I missing something?\n\nShall we eventually create an issue and move the discussion there? WDYT?",
      "parentUuid": "810c8abb_2a5baed2",
      "range": {
        "startLine": 811,
        "startChar": 10,
        "endLine": 811,
        "endChar": 33
      },
      "revId": "25e5fb56f110faf03163031d53b1953aa2974378",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9c39da97_ddc6b5cd",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 4
      },
      "lineNbr": 816,
      "author": {
        "id": 1022030
      },
      "writtenOn": "2023-12-07T05:54:23Z",
      "side": 1,
      "message": "Could this happen if there\u0027s a race where a ref doesn\u0027t exist at line 758, but then does exist at line 793? Otherwise I would expect 776 or 778 to have added the ref to newPacked.",
      "range": {
        "startLine": 816,
        "startChar": 29,
        "endLine": 816,
        "endChar": 46
      },
      "revId": "25e5fb56f110faf03163031d53b1953aa2974378",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "84875681_d9a6bf67",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 4
      },
      "lineNbr": 816,
      "author": {
        "id": 1012541
      },
      "writtenOn": "2023-12-07T11:53:49Z",
      "side": 1,
      "message": "Correct. I think this is the case.",
      "parentUuid": "9c39da97_ddc6b5cd",
      "range": {
        "startLine": 816,
        "startChar": 29,
        "endLine": 816,
        "endChar": 46
      },
      "revId": "25e5fb56f110faf03163031d53b1953aa2974378",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    }
  ]
}