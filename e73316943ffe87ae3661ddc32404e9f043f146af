{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "481e4186_884ea43c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 1015244
      },
      "writtenOn": "2025-01-23T14:09:18Z",
      "side": 1,
      "message": "@matthias.sohn@sap.com I believe this issue I am working on is somewhat related [1]\n\nWhen having a highly concurrent load (r/w) against a Gerrit on reftable with external GC processes scheduled, we found that `BlockSource` endup pointing to stale reftable resources.\n\nThe plan is check explicitly before attempting a read and then handle the exception appropriately (i.e. triggering a refresh/reload, similarly to what you do here).\n\n[1] https://eclipse.gerrithub.io/c/eclipse-jgit/jgit/+/1206693",
      "revId": "e73316943ffe87ae3661ddc32404e9f043f146af",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "518f9f36_0ba8baf8",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/FileReftableDatabase.java",
        "patchSetId": 5
      },
      "lineNbr": 191,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-01-23T13:37:40Z",
      "side": 1,
      "message": "I\u0027m not sure this is enough: the ref-table on disk may change after L191 during the execution of L192, and we may be returning the wrong outdated values or making an exception.\n\nI believe the correct structure should be a while/loop where:\n1. The reloadIfNecessary() should return a timestamp (or snapshot) S1\n2. We execute the body between L192 and L196\n3. We re-run reloadIfNecessary() and get the new timestamp (or snapshot) S2\n4. whilst S2 \u003c\u003e S1, we execute the loop again",
      "range": {
        "startLine": 191,
        "startChar": 2,
        "endLine": 191,
        "endChar": 21
      },
      "revId": "e73316943ffe87ae3661ddc32404e9f043f146af",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5c7fe6c6_7b3c9eb1",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/FileReftableDatabase.java",
        "patchSetId": 5
      },
      "lineNbr": 191,
      "author": {
        "id": 1038403
      },
      "writtenOn": "2025-01-24T18:18:50Z",
      "side": 1,
      "message": "I would say that looping should only happen on exceptions (when a result cannot be read), not because the files(ref) have changed after line 191. While it is true, that an out-of-date result may be returned, that is true no matter how much you loop, even once the files appear to no longer change (they can always change again after your check). What matters is not that the latest result is always returned (that is impossible), but that the result returned was accurate at least for a moment in time after the method call started. Therefore, I think it is wrong to be rechecking timestamps at the end unless we are trying to determine that a detected error condition (such as a caught exception) might have been caused by a change.",
      "parentUuid": "518f9f36_0ba8baf8",
      "range": {
        "startLine": 191,
        "startChar": 2,
        "endLine": 191,
        "endChar": 21
      },
      "revId": "e73316943ffe87ae3661ddc32404e9f043f146af",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "407e8cef_ff7f341a",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/FileReftableDatabase.java",
        "patchSetId": 5
      },
      "lineNbr": 191,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-01-24T21:58:27Z",
      "side": 1,
      "message": "\u003e I would say that looping should only happen on exceptions (when a result cannot be read), not because the files(ref) have changed after line 191. While it is true, that an out-of-date result may be returned,\n\nIt could be actually worse: if we are in a racy situation, then the data may be changing *whilst* we read and therefore the results may be inconsistent or, as you\u0027ve rightly pointed out, even cause exceptions.\n\nWe do the racy loop in PackDirectory.getPacks()\n\n```\ndo {\n\tlist \u003d packList.get();\n\tif (list \u003d\u003d NO_PACKS) {\n\t\tlist \u003d scanPacks(list);\n\t}\n} while (searchPacksAgain(list));\n```\n\n\u003e that is true no matter how much you loop, even once the files appear to no longer change (they can always change again after your check).\n\nTrue, but at least we know that *at the point of the return* the data was stable and did not change between the start and the end of the method.\nIf the data on disk is different on the start than at the end of the method, the read is definitely racy.\n\nSee the relevant discussion and presentation by Matthias many years ago at the Gerrit User Summit (https://youtu.be/m44cAozuLNI).\n\n\u003e What matters is not that the latest result is always returned (that is impossible), but that the result returned was accurate at least for a moment in time after the method call started.\n\nI respectfully disagree: it must be *consistent* and up-to-date to when the method ended. If the data on disk is changing, my read could be inconsistent, even there are no exception thrown.",
      "parentUuid": "5c7fe6c6_7b3c9eb1",
      "range": {
        "startLine": 191,
        "startChar": 2,
        "endLine": 191,
        "endChar": 21
      },
      "revId": "e73316943ffe87ae3661ddc32404e9f043f146af",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "08a2217f_c59c4f1b",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/FileReftableDatabase.java",
        "patchSetId": 5
      },
      "lineNbr": 191,
      "author": {
        "id": 1038403
      },
      "writtenOn": "2025-01-24T22:03:59Z",
      "side": 1,
      "message": "\u003e it must be consistent and up-to-date to when the method ended. If the data on disk is changing, my read could be inconsistent, even there are no exception thrown.\n\nI agree with this. I do believe that the design of the tables helps ensure this. RefTable files are immutable, so the data within an individual table file cannot change. The only thing that can change the view is the table list, and the existence of RefTable files. Once the file list is read, if the tables are looked up in the order of the list, and no tables are missed, the view should be guaranteed to be consistent with the original list.",
      "parentUuid": "407e8cef_ff7f341a",
      "range": {
        "startLine": 191,
        "startChar": 2,
        "endLine": 191,
        "endChar": 21
      },
      "revId": "e73316943ffe87ae3661ddc32404e9f043f146af",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    }
  ]
}