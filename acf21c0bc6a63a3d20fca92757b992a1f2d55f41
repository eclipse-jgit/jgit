{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "e860435f_f8fe66d1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000671
      },
      "writtenOn": "2024-02-13T21:46:23Z",
      "side": 1,
      "message": "rebased",
      "revId": "acf21c0bc6a63a3d20fca92757b992a1f2d55f41",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "66d8fb14_e2a6e3b5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-03-11T10:53:02Z",
      "side": 1,
      "message": "I\u0027m sorry for the late feedback; I believe this improves the situation, but there is still raciness left when refs are deleted. We see deleted refs being included in the packed-refs when the deletion is happening concurrently with the git repacking.",
      "revId": "acf21c0bc6a63a3d20fca92757b992a1f2d55f41",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "85ae4029_0ff96036",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 3
      },
      "lineNbr": 793,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-03-11T10:53:02Z",
      "side": 1,
      "message": "What if the loose ref is associated with a `refName` that was packed at L786 but then removed before reaching L794?\n\nI believe the locking of the loose refs should have happened *before* reading it and putting this into the `packed-refs`.\n\nThere is a race condition where the ref is removed *whilst* a ref\u0027s packing is processed.",
      "range": {
        "startLine": 793,
        "startChar": 6,
        "endLine": 793,
        "endChar": 14
      },
      "revId": "acf21c0bc6a63a3d20fca92757b992a1f2d55f41",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ab0c1bfa_ef334d10",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 3
      },
      "lineNbr": 793,
      "author": {
        "id": 1022030
      },
      "writtenOn": "2025-03-11T14:34:42Z",
      "side": 1,
      "message": "\u003e What if the loose ref is associated with a `refName` that was packed at L786 but then removed before reaching L794?\n\nI would want to check the code more and ideally write a test case to repro it, but it\u0027s possible that there\u0027s a bug here.\n\nThis code assumes that if there\u0027s no loose ref now then there also wasn\u0027t a loose ref at the time of populating `newPacked`. That might be the case, but it could also be a race like you describe where a loose ref (that is not in packed-refs at all) is deleted after we\u0027ve iterated refs and before we\u0027ve committed packed-refs.\n\nWe should be looking at `oldPacked` to check that case. If the ref isn\u0027t in `oldPacked` and doesn\u0027t exist as a loose ref now, we should be removing it from `newPacked` **before running `commitPackedRefs`**.\n\nIf the ref was in `oldPacked`, then the assumption here is safe because it would be a bug for anyone else to have removed the loose ref while we have the packed-refs lock since a packed-ref deletion needs that lock.\n\n\u003e \n\u003e I believe the locking of the loose refs should have happened *before* reading it and putting this into the `packed-refs`.\n\nIt\u0027s possible those loose refs were locked, but not for the normal `pack-refs` use case. There\u0027s a Map of `heldLocks` that\u0027s passed into this method and we only create a new loose ref lock on L799 if we don\u0027t already have the lock. It looks like that\u0027s only used by `PackedBatchRefUpdate` and it seems that\u0027s intented to cover a race condition with ref creation.\n\nI think the order you describe would work, but is probably too aggressive. We don\u0027t actually need to prevent updates to a loose ref, since a loose ref always has a higher precedence than the packed-refs anyway, we just want to avoid the deletion race for refs not already in packed-refs.\n\n\u003e \n\u003e There is a race condition where the ref is removed *whilst* a ref\u0027s packing is processed.\n\nMaybe we need a flow like this:\n1. Lock packed-refs (`oldPacked`)\n2. Get current packed refs (`newPacked`)\n3. Iterate loose refs and add/update in `newPacked`\na. During this iteration, track the set of loose refs that are added (i.e. not yet packed)\n4. For all *added* loose refs, lock them.\n5. Re-check existence of locked+added loose refs. Any non-existent refs are removed from `newPacked` and unlocked. Existent refs stay locked.\n6. Commit packed-refs (L786)\n7. Unlock added loose refs.\n8. Continue at L789.",
      "parentUuid": "85ae4029_0ff96036",
      "range": {
        "startLine": 793,
        "startChar": 6,
        "endLine": 793,
        "endChar": 14
      },
      "revId": "acf21c0bc6a63a3d20fca92757b992a1f2d55f41",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6d872d66_98828a9e",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 3
      },
      "lineNbr": 793,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-03-11T17:22:20Z",
      "side": 1,
      "message": "Let me write a test-case to demonstrate the bug.",
      "parentUuid": "ab0c1bfa_ef334d10",
      "range": {
        "startLine": 793,
        "startChar": 6,
        "endLine": 793,
        "endChar": 14
      },
      "revId": "acf21c0bc6a63a3d20fca92757b992a1f2d55f41",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0e2f59f4_d35ac2b2",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 3
      },
      "lineNbr": 793,
      "author": {
        "id": 1038403
      },
      "writtenOn": "2025-03-17T14:52:10Z",
      "side": 1,
      "message": "Nasser\u0027s 8 steps seem correct to me.",
      "parentUuid": "6d872d66_98828a9e",
      "range": {
        "startLine": 793,
        "startChar": 6,
        "endLine": 793,
        "endChar": 14
      },
      "revId": "acf21c0bc6a63a3d20fca92757b992a1f2d55f41",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e6589522_a4799c4e",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 3
      },
      "lineNbr": 793,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-03-17T15:32:20Z",
      "side": 1,
      "message": "I believe the most important point proposed by @quic_nasserg@quicinc.com is:\n\n\u003e Any non-existent refs are removed from newPacked and unlocked. Existent refs stay locked.\n\nIf you find out that a loose ref has disappeared between step 3. and step 4. they need to be removed from `newPacked` otherwise you end up restoring it by listing it into the packed refs.\n\nWith regards to 7. we could save time keeping them locked and removing them, instead of unlocking and re-locking them for removal.",
      "parentUuid": "0e2f59f4_d35ac2b2",
      "range": {
        "startLine": 793,
        "startChar": 6,
        "endLine": 793,
        "endChar": 14
      },
      "revId": "acf21c0bc6a63a3d20fca92757b992a1f2d55f41",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f4a7e9a6_d92300b0",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 3
      },
      "lineNbr": 793,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-05-15T11:20:12Z",
      "side": 1,
      "message": "\u003e For all added loose refs, lock them.\n\nThis issue happens for a very large number of refs (e.g. 1-2M refs). Locking all the refs would open a file for each ref and would run out of open files.",
      "parentUuid": "e6589522_a4799c4e",
      "range": {
        "startLine": 793,
        "startChar": 6,
        "endLine": 793,
        "endChar": 14
      },
      "revId": "acf21c0bc6a63a3d20fca92757b992a1f2d55f41",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "85bab8b4_38a8bf17",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 3
      },
      "lineNbr": 793,
      "author": {
        "id": 1022030
      },
      "writtenOn": "2025-05-15T16:34:41Z",
      "side": 1,
      "message": "\u003e \u003e For all added loose refs, lock them.\n\u003e \n\u003e This issue happens for a very large number of refs (e.g. 1-2M refs). Locking all the refs would open a file for each ref and would run out of open files.\n\nThis doesn\u0027t say \"all the refs\", it says \"all *added* loose refs\". Unless you\u0027re ref packing a repo with 1M loose refs (good luck ðŸ˜‚), I think it\u0027ll be ok.",
      "parentUuid": "f4a7e9a6_d92300b0",
      "range": {
        "startLine": 793,
        "startChar": 6,
        "endLine": 793,
        "endChar": 14
      },
      "revId": "acf21c0bc6a63a3d20fca92757b992a1f2d55f41",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9f7a7c85_b3313384",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 3
      },
      "lineNbr": 793,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-05-15T16:58:51Z",
      "side": 1,
      "message": "\u003e \u003e \u003e For all added loose refs, lock them.\n\u003e \u003e \n\u003e \u003e This issue happens for a very large number of refs (e.g. 1-2M refs). Locking all the refs would open a file for each ref and would run out of open files.\n\u003e \n\u003e This doesn\u0027t say \"all the refs\", it says \"all *added* loose refs\".\n\nWhen you don\u0027t have a `packed-refs` and you need to run the first `git pack-refs` the *added* loose refs are 1-2M refs.\n\n\u003e Unless you\u0027re ref packing a repo with 1M loose refs (good luck ðŸ˜‚)\n\nTested locally, my laptop can run a `git pack-refs` on a 2M refs repo in 2 minutes, without any problem or running out of open files. Also, JGit can run it today, but it won\u0027t be able to do it anymore if the `pack(refs)` has to lock 2M files at the same time.",
      "parentUuid": "85bab8b4_38a8bf17",
      "range": {
        "startLine": 793,
        "startChar": 6,
        "endLine": 793,
        "endChar": 14
      },
      "revId": "acf21c0bc6a63a3d20fca92757b992a1f2d55f41",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5ebaa02c_ca51d414",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 3
      },
      "lineNbr": 793,
      "author": {
        "id": 1038403
      },
      "writtenOn": "2025-05-15T17:00:24Z",
      "side": 1,
      "message": "If the lock is for a delete, it need not be an open file.",
      "parentUuid": "9f7a7c85_b3313384",
      "range": {
        "startLine": 793,
        "startChar": 6,
        "endLine": 793,
        "endChar": 14
      },
      "revId": "acf21c0bc6a63a3d20fca92757b992a1f2d55f41",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    }
  ],
  "submitRequirementResults": []
}