{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "e860435f_f8fe66d1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000671
      },
      "writtenOn": "2024-02-13T21:46:23Z",
      "side": 1,
      "message": "rebased",
      "revId": "acf21c0bc6a63a3d20fca92757b992a1f2d55f41",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "66d8fb14_e2a6e3b5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-03-11T10:53:02Z",
      "side": 1,
      "message": "I\u0027m sorry for the late feedback; I believe this improves the situation, but there is still raciness left when refs are deleted. We see deleted refs being included in the packed-refs when the deletion is happening concurrently with the git repacking.",
      "revId": "acf21c0bc6a63a3d20fca92757b992a1f2d55f41",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "85ae4029_0ff96036",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 3
      },
      "lineNbr": 793,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-03-11T10:53:02Z",
      "side": 1,
      "message": "What if the loose ref is associated with a `refName` that was packed at L786 but then removed before reaching L794?\n\nI believe the locking of the loose refs should have happened *before* reading it and putting this into the `packed-refs`.\n\nThere is a race condition where the ref is removed *whilst* a ref\u0027s packing is processed.",
      "range": {
        "startLine": 793,
        "startChar": 6,
        "endLine": 793,
        "endChar": 14
      },
      "revId": "acf21c0bc6a63a3d20fca92757b992a1f2d55f41",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ab0c1bfa_ef334d10",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 3
      },
      "lineNbr": 793,
      "author": {
        "id": 1022030
      },
      "writtenOn": "2025-03-11T14:34:42Z",
      "side": 1,
      "message": "\u003e What if the loose ref is associated with a `refName` that was packed at L786 but then removed before reaching L794?\n\nI would want to check the code more and ideally write a test case to repro it, but it\u0027s possible that there\u0027s a bug here.\n\nThis code assumes that if there\u0027s no loose ref now then there also wasn\u0027t a loose ref at the time of populating `newPacked`. That might be the case, but it could also be a race like you describe where a loose ref (that is not in packed-refs at all) is deleted after we\u0027ve iterated refs and before we\u0027ve committed packed-refs.\n\nWe should be looking at `oldPacked` to check that case. If the ref isn\u0027t in `oldPacked` and doesn\u0027t exist as a loose ref now, we should be removing it from `newPacked` **before running `commitPackedRefs`**.\n\nIf the ref was in `oldPacked`, then the assumption here is safe because it would be a bug for anyone else to have removed the loose ref while we have the packed-refs lock since a packed-ref deletion needs that lock.\n\n\u003e \n\u003e I believe the locking of the loose refs should have happened *before* reading it and putting this into the `packed-refs`.\n\nIt\u0027s possible those loose refs were locked, but not for the normal `pack-refs` use case. There\u0027s a Map of `heldLocks` that\u0027s passed into this method and we only create a new loose ref lock on L799 if we don\u0027t already have the lock. It looks like that\u0027s only used by `PackedBatchRefUpdate` and it seems that\u0027s intented to cover a race condition with ref creation.\n\nI think the order you describe would work, but is probably too aggressive. We don\u0027t actually need to prevent updates to a loose ref, since a loose ref always has a higher precedence than the packed-refs anyway, we just want to avoid the deletion race for refs not already in packed-refs.\n\n\u003e \n\u003e There is a race condition where the ref is removed *whilst* a ref\u0027s packing is processed.\n\nMaybe we need a flow like this:\n1. Lock packed-refs (`oldPacked`)\n2. Get current packed refs (`newPacked`)\n3. Iterate loose refs and add/update in `newPacked`\na. During this iteration, track the set of loose refs that are added (i.e. not yet packed)\n4. For all *added* loose refs, lock them.\n5. Re-check existence of locked+added loose refs. Any non-existent refs are removed from `newPacked` and unlocked. Existent refs stay locked.\n6. Commit packed-refs (L786)\n7. Unlock added loose refs.\n8. Continue at L789.",
      "parentUuid": "85ae4029_0ff96036",
      "range": {
        "startLine": 793,
        "startChar": 6,
        "endLine": 793,
        "endChar": 14
      },
      "revId": "acf21c0bc6a63a3d20fca92757b992a1f2d55f41",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6d872d66_98828a9e",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 3
      },
      "lineNbr": 793,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-03-11T17:22:20Z",
      "side": 1,
      "message": "Let me write a test-case to demonstrate the bug.",
      "parentUuid": "ab0c1bfa_ef334d10",
      "range": {
        "startLine": 793,
        "startChar": 6,
        "endLine": 793,
        "endChar": 14
      },
      "revId": "acf21c0bc6a63a3d20fca92757b992a1f2d55f41",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0e2f59f4_d35ac2b2",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 3
      },
      "lineNbr": 793,
      "author": {
        "id": 1038403
      },
      "writtenOn": "2025-03-17T14:52:10Z",
      "side": 1,
      "message": "Nasser\u0027s 8 steps seem correct to me.",
      "parentUuid": "6d872d66_98828a9e",
      "range": {
        "startLine": 793,
        "startChar": 6,
        "endLine": 793,
        "endChar": 14
      },
      "revId": "acf21c0bc6a63a3d20fca92757b992a1f2d55f41",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e6589522_a4799c4e",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 3
      },
      "lineNbr": 793,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-03-17T15:32:20Z",
      "side": 1,
      "message": "I believe the most important point proposed by @quic_nasserg@quicinc.com is:\n\n\u003e Any non-existent refs are removed from newPacked and unlocked. Existent refs stay locked.\n\nIf you find out that a loose ref has disappeared between step 3. and step 4. they need to be removed from `newPacked` otherwise you end up restoring it by listing it into the packed refs.\n\nWith regards to 7. we could save time keeping them locked and removing them, instead of unlocking and re-locking them for removal.",
      "parentUuid": "0e2f59f4_d35ac2b2",
      "range": {
        "startLine": 793,
        "startChar": 6,
        "endLine": 793,
        "endChar": 14
      },
      "revId": "acf21c0bc6a63a3d20fca92757b992a1f2d55f41",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f4a7e9a6_d92300b0",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 3
      },
      "lineNbr": 793,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-05-15T11:20:12Z",
      "side": 1,
      "message": "\u003e For all added loose refs, lock them.\n\nThis issue happens for a very large number of refs (e.g. 1-2M refs). Locking all the refs would open a file for each ref and would run out of open files.",
      "parentUuid": "e6589522_a4799c4e",
      "range": {
        "startLine": 793,
        "startChar": 6,
        "endLine": 793,
        "endChar": 14
      },
      "revId": "acf21c0bc6a63a3d20fca92757b992a1f2d55f41",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "85bab8b4_38a8bf17",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 3
      },
      "lineNbr": 793,
      "author": {
        "id": 1022030
      },
      "writtenOn": "2025-05-15T16:34:41Z",
      "side": 1,
      "message": "\u003e \u003e For all added loose refs, lock them.\n\u003e \n\u003e This issue happens for a very large number of refs (e.g. 1-2M refs). Locking all the refs would open a file for each ref and would run out of open files.\n\nThis doesn\u0027t say \"all the refs\", it says \"all *added* loose refs\". Unless you\u0027re ref packing a repo with 1M loose refs (good luck ðŸ˜‚), I think it\u0027ll be ok.",
      "parentUuid": "f4a7e9a6_d92300b0",
      "range": {
        "startLine": 793,
        "startChar": 6,
        "endLine": 793,
        "endChar": 14
      },
      "revId": "acf21c0bc6a63a3d20fca92757b992a1f2d55f41",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9f7a7c85_b3313384",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 3
      },
      "lineNbr": 793,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-05-15T16:58:51Z",
      "side": 1,
      "message": "\u003e \u003e \u003e For all added loose refs, lock them.\n\u003e \u003e \n\u003e \u003e This issue happens for a very large number of refs (e.g. 1-2M refs). Locking all the refs would open a file for each ref and would run out of open files.\n\u003e \n\u003e This doesn\u0027t say \"all the refs\", it says \"all *added* loose refs\".\n\nWhen you don\u0027t have a `packed-refs` and you need to run the first `git pack-refs` the *added* loose refs are 1-2M refs.\n\n\u003e Unless you\u0027re ref packing a repo with 1M loose refs (good luck ðŸ˜‚)\n\nTested locally, my laptop can run a `git pack-refs` on a 2M refs repo in 2 minutes, without any problem or running out of open files. Also, JGit can run it today, but it won\u0027t be able to do it anymore if the `pack(refs)` has to lock 2M files at the same time.",
      "parentUuid": "85bab8b4_38a8bf17",
      "range": {
        "startLine": 793,
        "startChar": 6,
        "endLine": 793,
        "endChar": 14
      },
      "revId": "acf21c0bc6a63a3d20fca92757b992a1f2d55f41",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5ebaa02c_ca51d414",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 3
      },
      "lineNbr": 793,
      "author": {
        "id": 1038403
      },
      "writtenOn": "2025-05-15T17:00:24Z",
      "side": 1,
      "message": "If the lock is for a delete, it need not be an open file.",
      "parentUuid": "9f7a7c85_b3313384",
      "range": {
        "startLine": 793,
        "startChar": 6,
        "endLine": 793,
        "endChar": 14
      },
      "revId": "acf21c0bc6a63a3d20fca92757b992a1f2d55f41",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6d58a634_f154f6d3",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 3
      },
      "lineNbr": 793,
      "author": {
        "id": 1022030
      },
      "writtenOn": "2025-05-15T17:04:36Z",
      "side": 1,
      "message": "\u003e my laptop can run a git pack-refs on a 2M refs repo in 2 minutes\n\nI was thinking on NFS, sorry. Agreed that locally with SSD the fs should be fine.\n\n\u003e If the lock is for a delete, it need not be an open file.\n\nActually it\u0027s never an open file. JGit creates lock files without keeping them open.",
      "parentUuid": "5ebaa02c_ca51d414",
      "range": {
        "startLine": 793,
        "startChar": 6,
        "endLine": 793,
        "endChar": 14
      },
      "revId": "acf21c0bc6a63a3d20fca92757b992a1f2d55f41",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "de6f0a49_8a920364",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 3
      },
      "lineNbr": 793,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-05-15T17:05:25Z",
      "side": 1,
      "message": "\u003e If the lock is for a delete, it need not be an open file.\n\nI believe the issue is that the `pack(refs)` method doesn\u0027t know if some other thread or process is about to remove any loose refs that are being packed, that\u0027s why I believe @nasser.grainawi@oss.qualcomm.com proposed to lock all the loose refs that are added, for preventing anyone else to remove them whilst they are being packed.\n\nThe way JGit manages locks is to create a loose ref with a `.lock` extension and keep it open. You\u0027re saying we could avoid keeping it open?",
      "parentUuid": "5ebaa02c_ca51d414",
      "range": {
        "startLine": 793,
        "startChar": 6,
        "endLine": 793,
        "endChar": 14
      },
      "revId": "acf21c0bc6a63a3d20fca92757b992a1f2d55f41",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "855a77c4_51a52024",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 3
      },
      "lineNbr": 793,
      "author": {
        "id": 1038403
      },
      "writtenOn": "2025-05-15T17:18:16Z",
      "side": 1,
      "message": "Where in the code do you believe it is doing this? From what I can tell, lockfiles are created in LockFile class:\n\n```\nprivate FS.LockToken createLockFile() throws IOException {\n  FileUtils.mkdirs(lck.getParentFile(), true);\n  return FS.DETECTED.createNewFileAtomic(lck);\n}\n```\n\nThis returns a LockToken which is an AutoCloseable, but that is a programming construct only, a LockToken only contains the following data\n```\nprivate boolean isCreated;\nprivate Optional\u003cPath\u003e link;\n```\nThere is no open file in this data.",
      "parentUuid": "de6f0a49_8a920364",
      "range": {
        "startLine": 793,
        "startChar": 6,
        "endLine": 793,
        "endChar": 14
      },
      "revId": "acf21c0bc6a63a3d20fca92757b992a1f2d55f41",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "011c7ec7_f0c82ee0",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 3
      },
      "lineNbr": 793,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-05-15T17:29:17Z",
      "side": 1,
      "message": "Gotcha. The lock is not kept as an open file. Still, we would need to limit the creation of 1-2M, which would take a significant amount of time and potentially blow up the inodes allowance on the filesystem.\n\nDoes the C git implementation lock all the individual refs being packed?",
      "parentUuid": "855a77c4_51a52024",
      "range": {
        "startLine": 793,
        "startChar": 6,
        "endLine": 793,
        "endChar": 14
      },
      "revId": "acf21c0bc6a63a3d20fca92757b992a1f2d55f41",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3b8797a4_99132732",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 3
      },
      "lineNbr": 793,
      "author": {
        "id": 1022030
      },
      "writtenOn": "2025-05-15T17:42:21Z",
      "side": 1,
      "message": "\u003e Does the C git implementation lock all the individual refs being packed?\n\nYes, but it appears to do that one-by-one (lock, check expected objectId, delete, unlock) in a separate (and optional) [`prune_refs`](https://github.com/git/git/blob/master/refs/files-backend.c#L1464) phase after writing and unlocking packed-refs.",
      "parentUuid": "011c7ec7_f0c82ee0",
      "range": {
        "startLine": 793,
        "startChar": 6,
        "endLine": 793,
        "endChar": 14
      },
      "revId": "acf21c0bc6a63a3d20fca92757b992a1f2d55f41",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c2433570_c4ea5432",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 3
      },
      "lineNbr": 793,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-05-15T17:49:22Z",
      "side": 1,
      "message": "\u003e \u003e Does the C git implementation lock all the individual refs being packed?\n\u003e \n\u003e Yes, but it appears to do that one-by-one (lock, check expected objectId, delete, unlock) in a separate (and optional) [`prune_refs`](https://github.com/git/git/blob/master/refs/files-backend.c#L1464) phase after writing and unlocking packed-refs.\n\nThat is what also JGit does today in `RefDirectory.java:806` at prune time.\n\n_\"Does the C git implementation lock all the invidual refs *being packed*\"_ \u003d\u003e no, they are not locked at pack time all at onece, but just later in the prune phase and one by one.\n\nI would suggest keeping the C git and JGit implementation more aligned. The C git implementation doesn\u0027t have the ref deletion issue, but JGit does. The loose ref locking strategy is the same, so the problem is elsewhere.",
      "parentUuid": "3b8797a4_99132732",
      "range": {
        "startLine": 793,
        "startChar": 6,
        "endLine": 793,
        "endChar": 14
      },
      "revId": "acf21c0bc6a63a3d20fca92757b992a1f2d55f41",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "876403b1_cde6dc7c",
        "filename": "org.eclipse.jgit/src/org/eclipse/jgit/internal/storage/file/RefDirectory.java",
        "patchSetId": 3
      },
      "lineNbr": 793,
      "author": {
        "id": 1022030
      },
      "writtenOn": "2025-05-29T22:03:36Z",
      "side": 1,
      "message": "\u003e There is a race condition where the ref is removed whilst a ref\u0027s packing is processed.\n\nWith the fix in [1c72895097f290b1fdea87bb4b62fb3517e5f14f](https://review.gerrithub.io/c/eclipse-jgit/jgit/+/1214781), we can\u0027t hit this condition now because deleting the loose ref will fail if packed-refs is already locked.",
      "parentUuid": "c2433570_c4ea5432",
      "range": {
        "startLine": 793,
        "startChar": 6,
        "endLine": 793,
        "endChar": 14
      },
      "revId": "acf21c0bc6a63a3d20fca92757b992a1f2d55f41",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    }
  ],
  "submitRequirementResults": []
}