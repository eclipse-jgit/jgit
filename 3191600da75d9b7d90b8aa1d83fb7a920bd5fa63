{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "76a0d6f4_04555552",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 11,
      "author": {
        "id": 1020855
      },
      "writtenOn": "2025-09-04T17:44:06Z",
      "side": 1,
      "message": "Move the description of the problem before the technical details. \n\nIf I understant correctly:\n```\nIn an unshallow fetch, shallow commits reachable multiple times are not emitted during the walk.\n\nWith a topology like this:\n\nA --- B --- C \u003c-[master]\n        \\\n          --- D \u003c- [v0.14.1]\n          \na client with B shallow gets this error from doing `git fetch --unshallow`:\n\nerror: Could not read (SHA1 of A)\nfatal: Failed to traverse parents of commit (SHA1 of B)\n```\n\nIf so, this should be the test!\n\nIf D doesn\u0027t exist and it is a single line history, unshallow works fine? \n\nwhat if B is not shallow, but A is? would the fetch work fine?",
      "revId": "3191600da75d9b7d90b8aa1d83fb7a920bd5fa63",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0859808e_87fc48b4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 11,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-09-04T18:29:33Z",
      "side": 1,
      "message": "\u003e Move the description of the problem before the technical details. \n\u003e \n\u003e If I understant correctly:\n\u003e ```\n\u003e In an unshallow fetch, shallow commits reachable multiple times are not emitted during the walk.\n\u003e \n\u003e With a topology like this:\n\u003e \n\u003e A --- B --- C \u003c-[master]\n\u003e         \\\n\u003e           --- D \u003c- [v0.14.1]\n\u003e           \n\u003e a client with B shallow gets this error from doing `git fetch --unshallow`:\n\u003e \n\u003e error: Could not read (SHA1 of A)\n\u003e fatal: Failed to traverse parents of commit (SHA1 of B)\n\u003e ```\n\u003e \n\u003e If so, this should be the test!\n\nI know, the introduction of the unshallow requests was made without any sort of testing, neither unit nor end-to-end. See https://eclipse.gerrithub.io/c/eclipse-jgit/jgit/+/1320.\n\nI\u0027ll check and add one specific test-case in the BasePackWriterTest.\n\n\u003e If D doesn\u0027t exist and it is a single line history, unshallow works fine? \n\nBy chance, the inconsistencies generated by a broken navigation were not enough to break the unshallow command from a client\u0027s perspective. The case I\u0027ve mentioned is *one* of the possible breakages, but I guess there could be many more.\n\nA code that isn\u0027t written to support a scenario, may behave in unexpected way in many unexpected and unsupported scenarios.\n\n\u003e what if B is not shallow, but A is? would the fetch work fine?\n\nA is the first commit, therefore is can never be a shallow clone.",
      "parentUuid": "76a0d6f4_04555552",
      "revId": "3191600da75d9b7d90b8aa1d83fb7a920bd5fa63",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "db455fab_df55f72b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 32,
      "author": {
        "id": 1020855
      },
      "writtenOn": "2025-09-04T17:44:06Z",
      "side": 1,
      "message": "Do you mean that, to solve the unshallow, the walk combines the depth+toposort+boundary generators. The depth generator does the right thing, but topo and boundary mess it up? Can you be more concrete?\n\ntoposort doesn\u0027t seem to check the UNSHALLOW flag, so I don\u0027t see why it should skip that commit.",
      "revId": "3191600da75d9b7d90b8aa1d83fb7a920bd5fa63",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9058be22_46818dc8",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 32,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-09-04T18:29:33Z",
      "side": 1,
      "message": "\u003e Do you mean that, to solve the unshallow, the walk combines the depth+toposort+boundary generators. The depth generator does the right thing, but topo and boundary mess it up? Can you be more concrete?\n\nAdded more concrete details on how the TopoSortGenerator and BoundaryGenerator behave with unshallow requests.\n\n\u003e toposort doesn\u0027t seem to check the UNSHALLOW flag, so I don\u0027t see why it should skip that commit.\n\nWell, the commit flagged with UNSHALLOW also has the UNINTERESTING flag because is part of the HAVEs in the fetch request.",
      "parentUuid": "db455fab_df55f72b",
      "revId": "3191600da75d9b7d90b8aa1d83fb7a920bd5fa63",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2d9ea07d_de3e678f",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1020855
      },
      "writtenOn": "2025-09-04T17:44:06Z",
      "side": 1,
      "message": "The combination of depth/topo/boundary sounds good to me, it should work as expected. Is there any chance we could fix the generators?",
      "revId": "3191600da75d9b7d90b8aa1d83fb7a920bd5fa63",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "11719234_5f83a0c3",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2025-09-04T18:29:33Z",
      "side": 1,
      "message": "My plan of attack is:\n\n1. Stable releases: We cannot really afford to refactor the code and move the UNSHALLOW flag to a static RevFlag into the RevWalk class, as it would potentially break other things. The functionality was merged with zero tests (you may notice that not a single class modified in Change 1320 is a test class), therefore even if the build would be green, we have no guarantees that something else would break.\n\n2. Master release: The fix should be done in two steps: refactoring the UNSHALLOW flag (step-a) to a static flag defined in RevWalk and multiple changes to make all the *Generator classes aware of the UNSHALLOW.\n\nOnce I\u0027ve merged this change on master, I\u0027d cherry-pick to the earliest stable support release we have on JGit and then merge-up.\nI don\u0027t like making big changes or refactoring on stable releases, because of the merge-up pain.\n\nWith the further refactoring of the RevFlag by introducing a globally available UNSHALLOW flag, I can then adapt the *Generator classes to make them aware of the new flag.\n\nUntil the above is done, it isn\u0027t save to use them for the unshallow requests. They may work (by mistake) and broken in multiple ways for different Git graphs topology.",
      "parentUuid": "2d9ea07d_de3e678f",
      "revId": "3191600da75d9b7d90b8aa1d83fb7a920bd5fa63",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    }
  ]
}